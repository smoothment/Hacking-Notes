# Introduction
---

With advancements in cyber security, many developers have adopted object-relational mapping (ORM) to mitigateÂ SQLÂ injection attacks. WhileÂ ORMÂ is intended to simplify database interactions and improve security, the threat of injection attacks is still not over.Â ORMÂ injection occurs when attackers exploit vulnerabilities withinÂ ORMÂ frameworks, allowing them to execute arbitrary queries. We will explore advancedÂ ORMÂ injection techniques in this room, providing an in-depth understanding of sophisticated attack vectors and effective mitigation strategies.  

By the end of this room, you will gain a comprehensive understanding of variousÂ ORMÂ injection methods, which will help you identify and exploit these vulnerabilities to safeguard web applications.  

Learning Objectives

ï»¿Throughout this room, you will gain a comprehensive understanding of the following key concepts:

- UnderstandingÂ ORM  
- Identifying Injection
- Weak Implementation
- Vulnerable Implementation

Learning Prerequisites

An understanding of the following topics is recommended before starting this room:

- [SQLÂ Injection](https://tryhackme.com/r/room/sqlinjectionlm)
- [OWASPÂ Top 10](https://tryhackme.com/room/owasptop10)

Let's begin!

# Understanding ORM
---

What isÂ ORM

ORMÂ is a programming technique that facilitates data conversion between incompatible systems using object-oriented programming languages. It allows developers to interact with a database using the programming language's native syntax, making data manipulation more intuitive and reducing the need for extensiveÂ SQLÂ queries.Â ORMÂ is particularly beneficial when complex data interactions are required, as it simplifies database access and promotes code reusability.Â 

![inter connectivity between orm and database](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1718912807353)  

Purpose

ORMÂ serves as a bridge between the object-oriented programming model and the relational database model. The primary purpose of anÂ ORMÂ is to abstract the database layer, allowing developers to work with objects rather than tables and rows. This abstraction layer helps in:

- **Reducing boilerplate code**:Â ORMÂ reduces the need for repetitive code by automatically generatingÂ SQLÂ queries based on object operations.
- **Increasing productivity**: Developers can focus on the business logic without worrying about database interactions.
- **Ensuring consistency**:Â ORMÂ frameworks consistently handle database operations, reducing the risk of errors.
- **Enhancing maintainability**: Changes to the database schema are easier to manage, as they can be reflected in the object model without extensive code modifications.

Commonly UsedÂ ORMÂ Frameworks

SeveralÂ ORMÂ frameworks are widely used in the development community, each catering to different programming languages and environments. Here are a few examples:

**Doctrine (PHP)**

Doctrine is a powerful and flexibleÂ ORMÂ framework forÂ PHP. It is particularly popular in the Symfony framework but can be used independently. Doctrine provides a comprehensive set of tools for database interactions, including a query builder, schema management, and an object-oriented query language. Its ability to map complex object structures to database schemas makes it a favourite amongÂ PHPÂ developers.

**Hibernate (Java)**

Hibernate is a robust and matureÂ ORMÂ framework for Java applications. It simplifies the mapping of Java classes to database tables and provides powerful data retrieval and manipulation capabilities through its Hibernate Query Language (HQL). Hibernate supports various database management systems and is known for its performance optimisation features, such as caching and lazy loading.

**SQLAlchemy (Python)**

SQLAlchemy is a versatile and powerfulÂ ORMÂ for Python. It offers anÂ SQLÂ toolkit and anÂ ORMÂ system that allows developers to use rawÂ SQLÂ when needed while still providing the benefits of anÂ ORM. SQLAlchemy's flexibility and modular architecture make it suitable for a wide range of applications, from small scripts to large-scale enterprise systems.

**Entity Framework (C#)**

Entity Framework is Microsoft'sÂ ORMÂ framework for .NET applications. It enables developers to work with relational data using domain-specific objects, eliminating the need for most data-access code that developers typically need to write. Entity Framework supports a variety of database providers and integrates seamlessly with other .NET technologies.

**Active Record (Ruby on Rails)**

Active Record is the defaultÂ ORMÂ for Ruby on Rails applications. It follows the Active Record design pattern, which means that each table in a database corresponds to a class, and each row in the table corresponds to an instance of that class. Active Record simplifies database interactions by providing a rich set of methods for querying and manipulating data.


# How ORM Works
---

### Mapping Between Objects in Code and Database Tables

ORMÂ is a technique that simplifies data interaction in an application by mapping objects in code to database tables. InÂ PHP, this process involves defining classes that represent database tables and their relationships. Each class property corresponds to a column in the table, and each class instance represents a row.

For instance, using Laravel's EloquentÂ ORM, you might define a model class like this:

```php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class User extends Model
{
    protected $table = 'users';
    protected $fillable = [
        'name', 'email', 'password',
    ];
    // Other Eloquent model configurations can go here...
}
```

In this example, theÂ `User`Â class maps to theÂ `users`Â table in the database, with properties corresponding to columns. EloquentÂ ORMÂ handles the translation between these object representations and the underlyingÂ SQLÂ queries, allowing developers to manipulate database records using object-oriented syntax.

CommonÂ ORMÂ Operations (Create, Read, Update, Delete)

ORMÂ frameworks streamline common database operations, often referred to as CRUD operations:

- **Create**: Creating new records in the database involves instantiating a new model object, setting its properties, and saving it to the database.

```php
use App\Models\User;

// Create a new user
$user = new User();
$user->name = 'Admin';
$user->email = 'admin@example.com';
$user->password = bcrypt('password'); 
$user->save();
```

This code creates a new user and saves it to the database. The save method prepares the entity for insertion and executes theÂ SQLÂ INSERT statement to add the new record to the users table. TheÂ `bcrypt()`Â function is used to securely hash the password before saving it.

- **Read**:Â Reading records from the database involves retrieving data using various Eloquent methods.

```php
use App\Models\User;

// Find a user by ID
$user = User::find(1);

// Find all users
$allUsers = User::all();

// Find users by specific criteria
$admins = User::where('email', 'admin@example.com')->get();
```

This code demonstrates different ways to retrieve records from the database. The functionÂ `find(1)`Â retrieves the user with ID 1 by executing a SELECT SQL statement. The functionÂ `all()`Â retrieves all users by executing aÂ `SELECT * FROM users`Â SQL statement. The clauseÂ `where('email', 'admin@example.com')->get()`Â retrieves users with the specified email by executing aÂ `SELECT * FROM users WHERE email = 'admin@example.com'`Â SQL statement.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719390696224)  

Similar to the create and read operations, the update and delete functionalities follow a straightforward approach using Laravel's Eloquent ORM. For updates, you retrieve the existing record, modify its properties, and save the changes. For deletions, you retrieve the record and call the delete method to remove it from the database. Eloquent handles the preparation and execution of the corresponding SQL statements, making database operations simple and intuitive.

Comparing SQL Injection and ORM Injection

SQL injection and ORM injection are both techniques used to exploit vulnerabilities in database interactions, but they target different levels of the stack:

- **SQL injection**: Targets raw SQL queries, allowing attackers to manipulate SQL statements directly. This is typically achieved by injecting malicious input into query strings. The injection part in the following query,Â `OR '1'='1`, always evaluates to true, allowing attackers to bypass authentication:

```php
SELECT * FROM users WHERE username = 'admin' OR '1'='1';
```

- **ORMÂ injection**: Targets theÂ ORMÂ framework, exploiting how it constructs queries from object operations. Attackers manipulate theÂ ORMâ€™s methods and properties to influence the resultingÂ SQLÂ queries.

```php
$userRepository->findBy(['username' => "admin' OR '1'='1"]);
```

In the above code, the injection part,Â `admin' OR '1'='1`, always evaluates to true.  

Key Differences in Exploitation Techniques

|   |   |   |
|---|---|---|
|**Aspect**|**SQLÂ Injection  <br>**|**ORMÂ Injection**|
|Level of injection|Targets rawÂ SQLÂ queries directly|Targets theÂ ORMÂ framework's query construction|
|Complexity|More straightforward, as it manipulates rawÂ SQL|Requires understanding ofÂ ORMÂ internals and methods|
|Detection|Easier to detect with traditional WAFs and query logs|Harder to detect, as payloads are withinÂ ORMÂ methods|
|Mitigation|Use of prepared statements, parameterised queries, input validation|ProperÂ ORMÂ configuration, application-level input validation,Â ORMÂ features enforcing query safety|

Configuring the Environment

Since we are using Laravel in this project, we will briefly explain how to configure EloquentÂ ORMÂ (Laravel-based). EloquentÂ ORMÂ is the defaultÂ ORMÂ included with Laravel, which provides a beautiful, simpleÂ `Active Record`Â implementation for working with your database.Â First, we need to install Laravel using Composer. Open your terminal and run the commandÂ `composer create-project --prefer-dist laravel/laravel thm-project`, whereÂ `thm-project`Â is the name of your project. You don't have to practice these steps in this room; this is just to help you understand how an ORM facilitates.

**Configure Database Credentials**  

Next, we need to configure our database credentials. Laravel uses theÂ `.env`Â file to store environment variables, including database credentials. Open theÂ `.env`Â file in the root of your Laravel project and update the following lines with your database details:

```php
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=your_database_name
DB_USERNAME=your_database_user
DB_PASSWORD=your_database_password
```

**Setting up Migrations**

Migrations are like version control for your database, allowing you to easily modify and share the database schema. Laravelâ€™s migration system is an essential part of the framework and simplifies the management of database changes.

**Create a Migration**

To create a migration, we can use theÂ `Artisan`Â command-line tool that comes with Laravel. You can run the commandÂ `php artisan make:migration create_users_table --create=users`Â to generate a migration for theÂ `users`Â table:

This command generates a migration file in the database/migrations directory. The migration file contains methods to define the structure of theÂ `users`Â table.

```php
<?php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
class CreateUsersTable extends Migration
{
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->string('password');
            $table->timestamps();
        });
    }
    public function down()
    {
        Schema::dropIfExists('users');
    }
}
```

In the above code, theÂ `up()`Â method defines the structure of theÂ `users`Â table. It includes columns for ID, name, email, password, and timestamps. Conversely, theÂ `down()`Â method dropsÂ theÂ `users`Â table if the migration is rolled back.

After defining the migration, run the commandÂ `php artisan migrate`Â to apply the migration and create theÂ `users`Â table in the database.Â This command will execute theÂ `up()`Â method in the migration file and create theÂ `users`Â table with the specified columns in your database.

In the context ofÂ ORM, migrations simplify the process of mapping database tables to application models. They enable developers to focus on writing clean, maintainable code while ensuring that the underlying database schema supports the application's data requirements. However, from a red team perspective, improperly configured migrations and weak implementations can lead to vulnerabilities likeÂ ORMÂ injection. Hackers often exploit these weaknesses to manipulate database queries and gain unauthorised access to sensitive data. Therefore, it is crucial to use migrations effectively to enforce strong, secure database schema designs and ensure robustÂ ORMÂ configurations to prevent such security flaws.

# Identifying ORM Injection
---

IdentifyingÂ ORMÂ injection vulnerabilities involves examining how user inputs are handled withinÂ ORMÂ queries. These vulnerabilities typically arise when user inputs are directly embedded intoÂ ORMÂ query methods without proper sanitisation or validation. Indicators of potentialÂ ORMÂ injection issues include the use of dynamic queries that concatenate user inputs, raw query execution methods, and insufficient use of parameterized queries.

Techniques for Testing ORM Injection

- **Manual code review**: A thorough source code inspection can reveal raw query methods (such asÂ `whereRaw()`Â in Laravel) that incorporate user inputs directly. Look for concatenated strings or unescaped inputs inÂ ORMÂ methods, which can indicate injection points.
- **Automated scanning**: Use security scanning tools that are designed to detectÂ ORMÂ injection vulnerabilities. These tools analyse the codebase to identify patterns that could lead to injection, such as dynamic query construction or improper input handling.
- **Input validation testing**: Perform manual testing by injecting payloads into application inputs to see if they affect the underlyingÂ ORMÂ query. For example, injectingÂ SQLÂ control characters or keywords to determine if they alter the execution of the query.
- **Error-based testing**: Enter deliberately incorrect or malformed data to trigger errors. Detailed error messages can provide insights into the structure of the underlying queries and indicate potential vulnerabilities.

**Frameworks andÂ ORMÂ Injection Testing**

|   |   |   |
|---|---|---|
|**Framework  <br>**|**ORMÂ Library  <br>**|**Common Vulnerable Methods  <br>**|
|Laravel|EloquentÂ ORM|`whereRaw(), DB::raw()`|
|Ruby on Rails|Active Record|`where("name = '#{input}'")`|
|Django|Django ORM|`extra()`,Â `raw()`|
|Spring|Hibernate|`createQuery()`Â withÂ `concatenation`|
|Node.js|Sequelize|`sequelize.query()`|

The table above highlights various web development frameworks and their associated ORM libraries, detailing common methods that are prone to vulnerabilities. For example, in Laravel, usingÂ `whereRaw()`Â orÂ `DB::raw()`Â with user inputs can lead to ORM injection, but this can be prevented by using parameterised queries with theÂ `where()`Â method. Similarly, in Django, methods likeÂ `extra()`Â andÂ `raw()`Â can introduce vulnerabilities if not handled correctly, while using the filter method with parameterised queries ensures safer database interactions. Understanding these common pitfalls and adopting secure coding practices is crucial for maintaining the security of web applications.

### Exploring the Target Application

Now that we know how to identifyÂ ORMÂ injection vulnerabilities, let's visit the site atÂ [https://LAB_WEB_URL.p.thmlabs.com](https://lab_web_url.p.thmlabs.com/).Â Here, you will see that the site prompts you for input. To determine which framework is being used, we can employ various techniques such as inspecting cookies, viewing the source code, and analysingÂ HTTPÂ headers.

#### **Techniques to Identify the Framework**

- **Verifying cookies**: Examine the cookies set by the application. Frameworks often use unique naming conventions or formats for their session cookies, which can provide clues about the underlying technology.

![viewing cookies to identify ORM](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719298104631)  

- **Reviewing source code**: Look through the HTML source code for comments, meta tags, or any embedded scripts that might reveal framework-specific signatures. However, this method may only sometimes be conclusive.

![viewing source code to identify ORM](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719298337669)  

- **AnalysingÂ HTTPÂ headers**:Â HTTPÂ headers can sometimes contain information about the server and framework. Tools likeÂ Burp SuiteÂ or browser developer tools can be used to inspect these headers.
- **URL structure**: The structure of URLs can give hints about the framework. For instance, certain routing patterns are unique to specific frameworks.
- **Login and error pages**: Authentication pages and error messages can sometimes reveal the framework. Some frameworks have distinctive error pages or login form structures.Â 

Now that we've identified that the application uses Laravel by inspecting the cookies, we can dig deeper by supplying malicious input to further explore its behaviour. Specifically, we'll inputÂ `1'`Â to see how the application handles this data and confirm ORM use. When we visit the site atÂ [https://LAB_WEB_URL.p.thmlabs.com](https://lab_web_url.p.thmlabs.com/),Â we are prompted to provide input. We enterÂ `1'`Â into theÂ **Email (Vulnerable)**Â input field and submit the form to determine how the application processes this input. This particular input is designed to disrupt the query structure and reveal any underlying issues with how the application constructs its queries.

![viewing error pages to identify ORM](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1718480201167)  

Upon submitting this input, we need to closely observe the application's response. If the application returns an error message, it can provide valuable insights into the query construction process. For instance, an error message such asÂ `SQLSTATE[42000]: Syntax error or access violation`Â indicates that the input has been improperly handled and concatenated into anÂ SQLÂ query, resulting in a syntax error. The output shows that it uses Laravel's EloquentÂ ORM, as the error messages and query patterns are characteristic of Eloquent's query builder.  

For red teamers, identifyingÂ ORMÂ injection vulnerabilities is critical to assessing an application's security posture.Â ORMÂ injection can be exploited if user inputs are not properly sanitised and validated, leading to unauthorised access or manipulation of database queries. Red teamers can uncover these vulnerabilities by employing techniques such as manual code review, automated scanning, and rigorous input validation testing. Using secure coding practices like parameterised queries and robust input validation is essential to mitigating the risks associated withÂ ORMÂ injection. Regular code reviews and the use of security tools can help developers identify and fix these issues.


# ORM Injection - Weak Implementation
---
In this task, we will explore how an attacker can exploitÂ ORMÂ vulnerabilities when theÂ ORMÂ is weakly implemented.Â To start, revisit the website atÂ [https://10-10-45-0.p.thmlabs.com](https://10-10-45-0.p.thmlabs.com/), where we have our two input fields that accept email input.

![dashboard displaying the search email form](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719303122392)  

Let's take a closer look at the source code used by the developer: to Let's take a closer look at the source code used by the developer for theÂ **Email (Vulnerable)**Â input field:

```php
public function searchBlindVulnerable(Request $request)
{
    $users = [];
    $email = $request->input('email');
    $users = Admins::whereRaw("email = '$email'")->get();
    if ($users) {
        return view('user', ['users' => $users]);
    } else {
        return view('user', ['message' => 'User not found']);
    }
}
```

  

What This Function Does  

TheÂ `searchBlindVulnerable()`Â function is designed to retrieve user records based on the email parameter provided by the user. Here's a detailed breakdown of the function:

- **Retrieve input**: The function captures theÂ `email`Â parameter from the HTTP request. This is done using the input method of theÂ `$request`Â object.
- **Construct query**: The function then constructs a raw SQL query using Laravel'sÂ `whereRaw()`Â method, which directly incorporates the email value into theÂ SQLÂ statement.
- **Execute query**: This query is executed, storing the result in theÂ `$users`Â variable.
- **Return view**: Finally, the function returns a view. If theÂ `$users`Â array is not empty, it passes the user data to the view; otherwise, it passes a "**User not found**" message.

The critical issue in this function lies in the direct use ofÂ `whereRaw()`Â with user input. This method of query construction is vulnerable to injection attacks because it does not sanitise the input.

An attacker can exploit this vulnerability by manipulating the email parameter. If an attacker inputsÂ `1' OR '1'='1`, the resultingÂ SQLÂ query becomes:

```php
SELECT * FROM users WHERE email = '1' OR '1'='1';
```

This query will always return all user records because the condition '1'='1' is perpetually true.

![A broken bridge representing injection between a database and code](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1718912926278)

Detailed ExploitationÂ 

- **Input malicious value**: The attacker visits the input field on the website and enters a crafted input, such asÂ `1' OR '1'='1`.
- **Query construction**: TheÂ `searchBlindVulnerable()`Â function receives this input and constructs the following query usingÂ `whereRaw()`:

```php
$users = User::whereRaw("email = '1' OR '1'='1'")->get();
```

This raw query construction directly inserts the malicious input into theÂ SQLÂ query.

- **Query execution**: Laravel's EloquentÂ ORMÂ translates this into theÂ SQLÂ statementÂ `SELECT * FROM users WHERE email = '1' OR '1'='1';`.
- **Result**: SinceÂ `'1'='1'`Â is always true, the query returns all records in the user's table. The attacker now has access to potentially sensitive information about all users in the database as shown below:

![search form after successful injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719304413178)  

Implementing SecureÂ ORMÂ Queries

Let's look at a secure version of the query function to demonstrate how secure implementation can protect againstÂ ORMÂ injection vulnerabilities. By using parameterised queries, we can ensure that user inputs are properly sanitised, significantly reducing the risk of injection attacks. Hereâ€™s a secure implementation of the function via theÂ **Email (Secure)**Â input field:  

```php
public function searchBlindSecure(Request $request)
{
    $email = $request->input('email');
    $users = User::where('email', $email)->get();
    if (isset($users) && count($users) > 0) {
        return view('user', ['users' => $users]);
    } else {
        return view('user', ['message' => 'User not found']);
    }
}
```

  

Breakdown of Secure Implementation

- **Retrieving input**: The function captures the email parameter from theÂ HTTPÂ request using the input method of theÂ `$request`Â object. This is the same as in the vulnerable version.
- **Constructing the query securely**: Instead of usingÂ `whereRaw()`, the secure version uses Eloquent'sÂ `where()`Â method. This method automatically escapes the input, thus preventing SQL injection. TheÂ `where()`Â method constructs a parameterised query behind the scenes, ensuring that user input is not directly included in theÂ SQLÂ statement.
- **Executing the query**: The query is executed, and the result is stored in theÂ `$users`Â variable. Because the query is parameterised, the input is sanitised, which means it cannot break the SQL query structure.
- **Returning the view**: Finally, the function returns a view. If theÂ `$users`Â array contains data, it passes the user data to the view; otherwise, it shows an error message.Â This logic ensures that only valid data is processed and displayed.

Now, try using the same malicious payloadÂ `1' OR '1'='1`Â with the secure implementation. Visit the website atÂ [https://10-10-45-0.p.thmlabs.com](https://10-10-45-0.p.thmlabs.com/)Â and enter the payload in theÂ **Email (Secure)**Â input field. When you submit this input, you will notice that the application does not break or return all user data.Â Instead, it behaves as expected, either finding no user with that email or returning the appropriate user data if a valid email is provided, as shown below:

![search form after unsuccessful injection attempt](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719304704357)

Why This Is Secure

- **Parameterised queries**: Parameterised queries ensure that the input values are treated as data only, not executable code. This prevents any injected SQL from being executed.
- **Automatic escaping**: Eloquent automatically escapes the input values, negating any special characters that could be used for SQL injection.
- **Consistent query logic**: By using Eloquent methods likeÂ `where()`, the query logic remains consistent and clear, making it easier to maintain and audit for security.  
    

The use ofÂ `whereRaw()`Â in the functionÂ `searchBlindVulnerable()`Â demonstrates a weak implementation ofÂ ORM, making the application highly susceptible to injection attacks. By understanding how user inputs are directly incorporated intoÂ SQLÂ queries, attackers can craft inputs to manipulate the query logic. This highlights the importance of using parameterised queries and proper input validation to secure web applications against such exploits.

![Pasted image 20250506125526.png](../../../IMAGES/Pasted%20image%2020250506125526.png)

![Pasted image 20250506125550.png](../../../IMAGES/Pasted%20image%2020250506125550.png)

# ORM Injection - Vulnerable Implementation
---
While secure coding practices are essential, it is also important to recognise how a developer might inadvertently implement a vulnerable version of anÂ ORM, creating avenues for exploitation. Vulnerable implementations can occur when developers useÂ **outdated or misconfiguredÂ ORMÂ libraries**Â that contain inherent security flaws. These flaws can be exploited by attackers to manipulate database queries and gain unauthorised access or control. Such vulnerabilities may stem from issues like improper handling of query parameters or inadequate protection against injection attacks within theÂ ORMÂ framework itself. Developers must ensure they are using up-to-date and secure versions ofÂ ORMÂ libraries to avoid introducing exploitable vulnerabilities into their applications.

Practical Example

One such example is the Laravel query builder package, which had a significant security vulnerability in versions prior to 1.17.1. This vulnerability allowedÂ SQLÂ injection through unsanitised query parameters. The vulnerability was identified in how the package handled sorting parameters directly from user input without proper validation. We have used theÂ [Spatie query builder](https://github.com/spatie/laravel-query-builder)Â in this example, which also uses the Laravel query builder internally to make queries.

To demonstrate this vulnerability, you can access the machine atÂ [https://10-10-45-0.p.thmlabs.com/query_users?sort=name](https://10-10-45-0.p.thmlabs.com/query_users?sort=name). This endpoint allows getting the top users sorted by theÂ `name`Â column via theÂ `sort`Â parameter.

![response after sorting users by name](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719171806193)  

The Laravel equivalent translation of the query isÂ `SELECT * FROM users ORDER BY name ASC LIMIT 2`.

**Injection Attempt**

If we try injecting the name parameter withÂ `name'`, we will see that the app returns an error that it couldnâ€™t find the column name.

![injection attempt by malicious input](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719479019501)  

Our objective here is to manipulate the query to retrieve complete data from theÂ `users`Â table instead of being restricted to a limited number of rows.  

However, injecting the sort parameter in this context is not straightforward by merely concatenating it with theÂ `SELECT`Â query and using routine injection methods. The challenge lies in effectively breaking out of the ORDER BY clause to manipulate the query execution. To achieve this, we can utilize a special function: theÂ [->](https://dev.mysql.com/doc/refman/8.4/en/json.html)Â operator, which serves as an alias for theÂ `json_extract`Â function in MySQL. This operator allows us to navigateÂ JSONÂ data and extract specific values. By using theÂ `->`Â operator in conjunction with theÂ `"%27))`Â payload, we can break out of the ORDER BY clause. TheÂ `->"%27))`Â payload effectively terminates the JSON extraction, bypasses the limitations imposed by the initial queryÂ and allows us to append additional SQL commands.

**Final Payload**

We will prepare the final payload like this:

- **Initial query**: The initial query that Laravel translates for sorting users by name isÂ `SELECT * FROM users ORDER BY name ASC LIMIT 2`.
- **Breaking the query**: By injecting theÂ `name->"%27))`, we can cause the query to break and thus create an opportunity to insert our own SQL.
- **Crafting the payload**: To exploit the vulnerability, we craft the payload to break out of the string and inject our SQL. The payload would be something likeÂ `name->"%27)) SQL INJECTION QUERY #`. Within the parameter valueÂ `name->`, theÂ `->`Â is parsed by Laravel and replaced with JSON MySQL function. On the other hand,Â `"%27))`Â closes the previous string and condition.Â `SQL INJECTION QUERY`Â allows an attacker to write his own query. The characterÂ `#`Â comments out the rest of the query to prevent syntax errors.
- **Final result**: The payload for getting additional rows from the database would look likeÂ [https://10-10-45-0.p.thmlabs.com/query_users?sort=name-%3E%22%27))%20LIMIT%2010%23](https://10-10-45-0.p.thmlabs.com/query_users?sort=name-%3E%22%27\)\)%20LIMIT%2010%23), while the query generated by Laravel to the MySQL database would beÂ ``SELECT * FROM `users` ORDER BY json_unquote(json_extract(`name`, '$.""')) LIMIT 10#"')) ASC LIMIT 2``Â including the injected payload. The above query would bypass the limit capability and fetch 10 rows from the table.

![successful injection for getting maximum rows from users table](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1719171665479)  

The above example highlights the critical importance of input validation and sanitisation in preventingÂ ORMÂ injection vulnerabilities. By understanding how seemingly harmless query parameters can be exploited, developers can better appreciate the need for secure coding practices. UsingÂ ORMÂ features without a proper grasp of their implications can inadvertently expose applications to serious security risks.


![Pasted image 20250506125724.png](../../../IMAGES/Pasted%20image%2020250506125724.png)


# Best Practices
---
Now that we understand the threat surface ofÂ ORMÂ injection, preventing these vulnerabilities requires implementing robust security measures and continuously monitoring potential weaknesses. The following sections outline best practices for securing user inputs and leveraging automation techniques to effectively identify and mitigate injection vulnerabilities.

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1718912983084)

Few Important Practices

- **Input validation**: Always validate user inputs on both client and server sides. Ensure that the data conforms to the expected format, type, and length. Use regular expressions and built-in validation functions to enforce strong input validation rules.
- **Parameterised queries**: Use parameterised queries (prepared statements) to interact with the database. This approach ensures that user inputs are treated as data, not executable code. Avoid concatenating user inputs directly intoÂ SQLÂ queries.
- **ORMÂ usage**: UtiliseÂ ORMÂ built-in tools to interact with the database. ORMs abstractÂ SQLÂ queries and help preventÂ SQLÂ injection by handling user inputs securely. Ensure that theÂ ORMÂ is configured correctly and that any customÂ SQLÂ queries are parameterised.
- **Escaping and sanitisation**: Escape user inputs to remove any special characters used for injection attacks. Sanitise inputs to remove potentially harmful data before processing or storing it.
- **Allowlist input**: Implement an allowlist approach for input validation. Only allow specific, expected values and reject everything else. This method is more secure than blocklisting known bad values, which can be incomplete.

Application in Popular Frameworks

We'll explore essential practices for safeguarding againstÂ ORMÂ injection in widely usedÂ ORMÂ frameworks.Â ORMÂ tools like Doctrine (PHP), SQLAlchemy (Python), Hibernate (Java), and Entity Framework (.NET) provide powerful abstractions for database interactions. However, to preventÂ SQLÂ injection vulnerabilities, it's crucial to employ secure coding practices such as parameterised queries, named parameters, andÂ ORM-specific techniques. Let's delve into these best practices with practical examples for each framework:

**Doctrine (PHP)**

Use prepared statements with parameterised queries to preventÂ SQLÂ injection attacks.

```php
$query = $entityManager->createQuery('SELECT u FROM User u WHERE u.username = :username');
$query->setParameter('username', $username);
$users = $query->getResult();
```

**SQLAlchemy (Python)**

Leverage SQLAlchemy'sÂ ORMÂ and QueryÂ APIÂ to use parameterised queries, which automatically handle escaping and parameter binding.

```php
from sqlalchemy.orm import sessionmaker
Session = sessionmaker(bind=engine)
session = Session()
user = session.query(User).filter_by(username=username).first()
```

**Hibernate (Java)**

Use named parameters with Hibernate's QueryÂ APIÂ to ensure inputs are adequately bound and escaped.

```php
String hql = "FROM User WHERE username = :username";
Query query = session.createQuery(hql);
query.setParameter("username", username);
List results = query.list();
```

**Entity Framework (.NET)**

Employ parameterised queries in Entity Framework to secure database interactions and mitigate the risk ofÂ SQLÂ injection vulnerabilities.

```php
var user = context.Users.FirstOrDefault(u => u.Username == username);
```

These practices underscore the importance of adopting secure coding practices tailored to eachÂ ORMÂ framework, ensuring robust protection againstÂ ORMÂ injection vulnerabilities.

# Conclusion
---

Throughout our exploration ofÂ ORMÂ injection, we began by establishing a solid understanding of whatÂ ORMÂ entails and its fundamental role in modern web development. We explored its workings, understanding how ORMs abstract database interactions into object-oriented paradigms, enhancing developer productivity and code maintainability.

Moving forward, we shifted focus to the perspective of a penetration tester, learning how to identify potential injection vulnerabilities, specifically within Laravel, a widely usedÂ PHPÂ framework. With this foundational knowledge, we examined the exploitation of poorly implementedÂ ORMÂ systems. We uncovered how vulnerabilities inÂ ORMÂ configurations can lead to injection attacks, allowing malicious actors to manipulate database queries and potentially gain unauthorised access to sensitive information.

To conclude, we highlighted essential security practices within popular frameworks. These practices include rigorous input validation, proper use of parameterised queries or prepared statements to mitigate injection risks, and leveragingÂ ORMÂ frameworks with built-in security features. By adopting these practices, developers can safeguard their applications againstÂ ORMÂ injection vulnerabilities, ensuring a well-protected and secure web application.

