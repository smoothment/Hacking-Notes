# Introduction
---

HTTPÂ Request Smuggling is a vulnerability that arises when there are mismatches in different web infrastructure components. This includes proxies, load balancers, and servers that interpret the boundaries ofÂ HTTPÂ requests. For example, consider a train station where tickets are checked at multiple points before boarding. If each checkpoint has different criteria for a valid ticket, a traveller could exploit these inconsistencies to board a train without a valid ticket. Similarly, in web requests, this vulnerability mainly involves the Content-Length and Transfer-Encoding headers, which indicate the end of a request body. When these headers are manipulated or interpreted inconsistently across components, it may result in one request being mixed with another.  

![HTTP Request Smuggling Process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/0b4b7fd545543eff34d7817fcf2e26a3.svg)

Request splitting orÂ HTTPÂ desync attacks are possible because of the nature of keep-alive connections andÂ HTTPÂ pipelining, which allow multiple requests to be sent over the sameÂ TCPÂ connection. Without these mechanisms, request smuggling wouldn't be feasible. When calculating the sizes for Content-Length (CL) and Transfer-Encoding (TE), it's crucial to consider the presence of carriage returnÂ `\r`Â and newlineÂ `\n`Â characters. These characters are not only part of theÂ HTTPÂ protocol's formatting but also impact the calculation of content sizes.

While testing for request smuggling vulnerabilities, it's important to note that some tools might automatically "fix" the Content-Length header by default. This means if you're using such tools to run payloads, your Content-Length values might get overwritten, potentially changing the test results.

Note that testing for request smuggling can potentially break a website in many ways (cache poisoning, other user requests may start failing, or even the back-end pipeline might get fully desynced), so extreme care should be taken when testing this on a production website.

#### Objectives

1. Understand whatÂ HTTPÂ Request Smuggling is and its impact.
2. IdentifyÂ HTTPÂ Request SmugglingÂ vulnerabilities in web applications.
3. Exploit these vulnerabilities in a controlled environment.
4. Understand and apply measures to mitigate and prevent these vulnerabilities.

#### Pre-requisites

1. Basic understanding ofÂ HTTP/1.1 protocol and its headers. You can take a look at thisÂ [room](https://tryhackme.com/room/httpindetail)Â for a more detailed explanation.
2. Familiarity with web server infrastructure components like load balancers, proxies, and web servers.
3. Basic understanding and usage of aÂ proxyÂ tool likeÂ [Burp Suite](https://tryhackme.com/room/burpsuiterepeater).

#### Importance of UnderstandingÂ HTTPÂ Request Smuggling

1. Smuggled requests might evade security mechanisms like Web Application Firewalls. This potentially leads to unauthorized access or data leaks.
2. Attackers can poison web caches by smuggling malicious content, causing users to see incorrect or harmful data.
3. Smuggled requests can be chained to exploit other vulnerabilities in the system, amplifying the potential damage.
4. Due to the intricate nature of this vulnerability, it can often go undetected, making it crucial for security professionals to understand and mitigate it.

# Modern Infrastructure
----
#### Components of Modern Web Applications

Modern web applications are no longer straightforward, monolithic structures. They are composed of different components that work with each other. Below are some of the components that a modern web application usually consists of:

1. **Front-end server**: This is usually the reverseÂ proxyÂ or load balancer that forwards the requests to the back-end.
2. **Back-end server**: This server-side component processes user requests, interacts with databases, and serves data to the front-end. It's often developed using languages likeÂ PHP, Python, and Javascript and frameworks like Laravel, Django, or Node.js.
3. **Databases**: Persistent storage systems where application data is stored. Examples of this are databases like MySQL, PostgreSQL, and NoSQL.
4. **APIs (Application Programming Interfaces)**: Interfaces allow the front and back-end to communicate and integrate with other services.
5. **Microservices**: Instead of a single monolithic back-end, many modern applications use microservices, which are small, independent services that communicate over a network, often usingÂ HTTP/RESTÂ or gRPC.

#### Load Balancers and Reverse Proxies

1. **Load Balancers**: These devices or services distribute incoming network traffic across multiple servers to ensure no single server is overwhelmed with too much traffic. This distribution ensures high availability and reliability by redirecting requests only to online servers that can handle them.Â Load balancing for web servers is often done by reverse proxies. Examples includeÂ AWSÂ Elastic Load Balancing, HAProxy, and F5 BIG-IP.
2. **Reverse Proxies**: A reverseÂ proxyÂ sits before one or more web servers and forwards client requests to the appropriate web server. While they can also perform load balancing, their primary purpose is to provide a single access point and control for back-end servers. Examples include NGINX,Â ApacheÂ with mod_proxy, and Varnish.

![How load balancer and reverse proxies work](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/adaa5ac3ca48557bdf12e4b7758fd429.svg)

#### Role of Caching Mechanisms

Caching is a technique used to store and reuse previously fetched data or computed results to speed up subsequent requests and computations. In the context of web infrastructure:

1. **Content Caching**: By storing web content that doesn't change frequently (like images, CSS, and JS files), caching mechanisms can reduce the load on web servers and speed up content delivery to users.
2. **Database Query Caching**: Databases can cache the results of frequent queries, reducing the time and resources needed to fetch the same data repeatedly.
3. **Full-page Caching**: Entire web pages can be cached, so they don't need to be regenerated for each user. This is especially useful for websites with high traffic.
4. **Edge Caching/CDNs**: Content Delivery Networks (CDNs) cache content closer to the users (at the "edge" of the network), reducing latency and speeding up access for users around the world.
5. **APIÂ Caching**: Caching the responses can significantly reduce back-end processing for APIs that serve similar requests repeatedly.

Caching, when implemented correctly, can significantly enhance the performance and responsiveness of web applications. However, managing caches properly is essential to avoid serving stale or outdated content.

# Behind the Scenes
---

#### UnderstandingÂ HTTPÂ Request Structure

EveryÂ HTTPÂ request comprises two main parts: the header and the body.

![HTTP Structure](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/802fad8f6515cfe16750e11e4b89957a.png)  

1. **Request Line**: The first line of the requestÂ `POST /admin/login HTTP/1.1`Â is the request line. It consists of at least three items. First is the method, which in this case is "POST". The method is a one-word command that tells the server what to do with the resource. Second is the path component of the URL for the request. The path identifies the resource on the server, which in this case is "/admin/login". Lastly, theÂ HTTPÂ version number shows theÂ HTTPÂ specification to which the client has tried to make the message comply. Note thatÂ HTTP/2 andÂ HTTP/1.1 have different structures.
2. **Request Headers**: This section contains metadata about the request, such as the type of content being sent, the desired response format, and authentication tokens. It's like the envelope of a letter, providing information about the sender, receiver, and the nature of the content inside.
3. **Message Body**: This is the actual content of the request. The body might be empty for a GET request, but for a POST request, it could contain form data,Â JSONÂ payloads, or file uploads.

#### Content-Length Header

The Content-Length header indicates the request or response body size in bytes. It informs the receiving server how much data to expect, ensuring the entire content is received.

Content-Length Sample Request

```shell-session
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 14
    
q=smuggledData
```

This means that the request or response body contains 14 bytes of data.

#### Transfer-Encoding Header

The Transfer-Encoding header is used to specify the form of encoding applied to the message body of anÂ HTTPÂ request or response. A commonly used value for this header is "chunked", indicating that the message body is divided into a series of chunks, each preceded by its size in hexadecimal format. Other possible values for the Transfer-Encoding header include "compress", "deflate", and "gzip", each indicating a different type of encoding. For example:  

Transfer-Encoding Sample Request

```shell-session
POST /submit HTTP/1.1
Host: good.com
Content-Type: application/x-www-form-urlencoded
Transfer-Encoding: chunked
    
b
q=smuggledData 
0
```

In this example, "b" (in hexadecimal, equivalent to 11 in decimal) specifies the size of the following chunk. The chunkÂ `q=smuggledData`Â is the actual data, followed by a new line. The request is terminated with a "0" line, indicating the end of the message body. Each chunk size is given in hexadecimal format, and the end of the chunked body is signified by a chunk of size 0.

#### How Headers Affect Request Processing

Headers play an important role in guiding the server to process the request. This is because they determine how to parse the request body andÂ influence caching behaviours. They can also affect authentication, redirection, and other server responses.

![How headers affects request process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/2e8e7deef6eaa04f3461647e61bf3566.svg)

Manipulating headers like Content-Length and Transfer-Encoding can create vulnerabilities. For instance, if aÂ proxyÂ server gets confused by these headers, it might not properly distinguish where one request ends and another starts.

#### HTTPÂ Request Smuggling Origin

HTTPÂ Request Smuggling primarily occurs due to discrepancies in how different servers (like a front-end server and a back-end server) interpretÂ HTTPÂ request boundaries. For example:

1. If both Content-Length and Transfer-Encoding headers are present, ambiguities can arise.
2. Some components prioritize Content-Length, while others prioritize Transfer-Encoding.
3. This discrepancy can lead to one component believing the request has ended while another thinks it's still ongoing, leading to smuggling.

**Example:**Â Suppose a front-end server uses the Content-Length header to determine the end of a request while a back-end server uses the Transfer-Encoding header. An attacker can craft a request that appears to have one boundary to the front-end server but a different boundary to the back-end server. This can lead to one request being "smuggled" inside another, causing unexpected behaviour and potential vulnerabilities.

![How http request smuggling arise](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/ab54d526056376d18ee9474e32884261.png)


# Request Smuggling CL.TE
----

#### Introduction to CL.TE request smuggling

**CL.TE**Â stands forÂ **Content-Length/Transfer-Encoding**. The nameÂ **CL.TE**Â comes from the two headers involved:Â **Content-Length**Â andÂ **Transfer-Encoding**.Â In CL.TE technique, the attacker exploits discrepancies between how different servers (typically a front-end and a back-end server) prioritize these headers. For example:

- TheÂ proxyÂ uses the Content-Length header to determine the end of a request.
- The back-end server uses the Transfer-Encoding header.

![How CL.TE request smuggling works](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/ab54d526056376d18ee9474e32884261.png)  

Because of this discrepancy, it's possible to craft ambiguous requests that are interpreted differently by each server. For example, Imagine sending a request with bothÂ `Content-Length`Â andÂ `Transfer-Encoding`Â headers. The front-end server might use the Content-Length header and think the request ends at a certain point due to the provided number of bytes. In contrast, the back-end server, relying on the Transfer-Encoding header, might interpret the request differently, leading to unexpected behaviour.

#### Exploiting CL.TE for Request Smuggling

To exploit the CL.TE technique, an attacker crafts a request that includes both headers, ensuring that the front-end and back-end servers interpret the request boundaries differently.Â For example, an attacker sends a request like:

Sample Request

```http
POST /search HTTP/1.1
Host: example.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
```

Here, the front-end server sees theÂ `Content-Length`Â of 130 bytes and believes the request ends afterÂ Â `isadmin=true`. However, the back-end server sees theÂ `Transfer-Encoding: chunked`Â and interprets theÂ `0`Â as the end of a chunk, making the second request the start of a new chunk. This can lead to the back-end server treating theÂ `POST /update HTTP/1.1`Â as a separate, new request, potentially giving the attacker unauthorized access.

#### Incorrect Content-Length

When creating a request smuggling payload,Â if theÂ `Content-Length`Â is not equal to the actual length of the content, several problems might arise. First, the server might process only the portion of the request body that matches theÂ `Content-Length`. This could result in the smuggled part of the request being ignored or not processed as intended. For example, in the below screenshot, the original size of the body is 24 bytes.

![correct content-length header](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/e0f2e11582632abc3dd6740479cec405.png)

To verify that the Content-Length is valid, we can check theÂ `/submissions`Â directory to verify if the whole body was saved in the .txt file.

![Complete request saved successfully](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/8a77de10e519a7bcd3dda9d01f52bd00.png)

Since the size of the bodyÂ `username=test&query=test`Â is 24 bytes, sending a Content-Length with a size lower than this will instruct the back-end server to interpret the request body differently. For example, when the Content-Length is set to less than the actual size of the bodyÂ `username=test&query=test`Â (which is 24 bytes), the back-end server will only read part of the request body based on the specified Content-Length. For instance, setting Content-Length to 10 bytes means the server will only consider the first 10 bytes of the body, leading to incomplete data being processed.

![Incorrect content-length header](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/7e822ba73974d15e6f31c1f1203abc27.png)

![Incomplete data were saved](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/0f6e34de100123485e8b37fb9cebf86c.png)


  
# Request Smuggling TE.CL
---

**TE.CL**Â stands forÂ **Transfer-Encoding/Content-Length**. This technique is the opposite of the CL.TE method. In the TE.CL approach, the discrepancy in header interpretation is flipped because the front-end server uses the Transfer-Encoding header to determine the end of a request, and the back-end server uses the Content-Length header.

The TE.CL technique arises when theÂ proxyÂ prioritizes theÂ `Transfer-Encoding`Â header while the back-end server prioritizes theÂ `Content-Length`Â header.

![How TE.CL smuggling works](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/09d9384ce4e37f489e6996c47f072f54.png)  

**Example:**Â If an attacker sends a request with both headers, the front-end server orÂ proxyÂ might interpret the request based on theÂ `Transfer-Encoding`Â header, while the back-end server might rely on theÂ `Content-Length`Â header. This difference in interpretation might interpret the request differently, leading to unexpected behaviour.

#### Exploiting TE.CL for Request Smuggling

To exploit the TE.CL technique, an attacker crafts a specially designed request that includes both theÂ **Transfer-Encoding**Â andÂ **Content-Length**Â headers, aiming to create ambiguity in how the front-end and back-end servers interpret the request.  

For example, an attacker sends a request like:


```http
POST / HTTP/1.1
Host: example.com
Content-Length: 4
Transfer-Encoding: chunked

78
POST /update HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

isadmin=true
0
```

In the above payload, the front-end server sees theÂ `Transfer-Encoding: chunked`Â header and processes the request as chunked. TheÂ `78`Â (hexadecimal for 120) indicates that the next 120 bytes are part of the current request's body. The front-end server considers everything up to theÂ `0`Â (indicating the end of the chunked message) as part of the body of the first request.

The back-end server, however, uses the Content-Length header, which is set to 4. It processes only the first 4 bytes of the request, not including the entire smuggled requestÂ `POST /update`. The remaining part of the request, starting fromÂ **POST /update**, is then interpreted by the back-end server as a separate, new request.

The smuggled request is processed by the back-end server as if it were a legitimate, separate request. This request includes theÂ `isadmin=true`Â parameter, which could potentially elevate the attacker's privileges or alter data on the server, depending on the application's functionality.

# Transfer Encoding Obfuscation
---
#### Introduction to TE.TE Technique

**Transfer Encoding Obfuscation,**Â also known asÂ **TE.TE**Â stands forÂ **Transfer-Encoding/Transfer-Encoding**. Unlike the CL.TE or TE.CL methods, the TE.TE technique arises when both the front-end and the back-end servers use the Transfer-Encoding header.Â In TE.TE technique, the attacker takes advantage of the servers' inconsistent handling ofÂ  Transfer-Encoding present in theÂ HTTPÂ headers.

The TE.TE vulnerability doesn't always require multiple Transfer-Encoding headers. Instead, it often involves a single, malformed Transfer-Encoding header that is interpreted differently by the front-end and back-end servers. In some cases, the front-end server might ignore or strip out the malformed part of the header and process the request normally, while the back-end server might interpret the request differently due to the malformed header, leading to request smuggling.  

![How TE.TE request smuggling works](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/185d7a5ec0d23cad9c5947ed338f00cb.svg)

**Example**:Â An attacker manipulates the Transfer-Encoding header by including "chunked" in malformed variations. This is done to exploit how front-end and back-end servers prioritize the Transfer-Encoding (TE) header over Content-Length (CL). By crafting malformed Transfer-Encoding headers, the attacker aims to make one server ignore the TE header and use CL instead, leading to a discrepancy in how the request boundaries are interpreted between the front-end and back-end servers. This manipulation can result in either a CL.TE or TE.CL situation, depending on which server falls back to using the Content-Length.

#### Exploiting TE.TE for Request Smuggling

To exploit the TE.TE technique, an attacker may craft a request that includes Transfer-Encoding headers that use different encodings.Â For example, an attacker sends a request like:

Sample Request

```shell-session
POST / HTTP/1.1
Host: example.com
Content-length: 4
Transfer-Encoding: chunked
Transfer-Encoding: chunked1

4e
POST /update HTTP/1.1
Host: example.com
Content-length: 15

isadmin=true
0
```

In the above payload, the front-end server encounters twoÂ `Transfer-Encoding`Â headers. The first one is a standard chunked encoding, but the second one,Â `chunked1`, is non-standard. Depending on its configuration, the front-end server might process the request based on the firstÂ `Transfer-Encoding: chunked`Â header and ignore the malformedÂ `chunked1`, interpreting the entire request up to theÂ `0`Â as a single chunked message.

The back-end server, however, might handle the malformedÂ `Transfer-Encoding: chunked1`Â differently. It could either reject the malformed part and process the request similarly to the front-end server or interpret the request differently due to the presence of the non-standard header. If it processes only the first 4 bytes as indicated by theÂ `Content-length: 4`, the remaining part of the request starting fromÂ `POST /update`Â is then treated as a separate, new request.

The smuggled request with theÂ `isadmin=true`Â parameter is processed by the back-end server as if it were a legitimate, separate request. This could lead to unauthorized actions or data modifications, depending on the server's functionality and the nature of the /update endpoint.

# Walkthrough
---

#### Assessing the Application

The web application for this room uses the linkÂ [http://httprequestsmuggling.thm](http://httprequestsmuggling.thm/). It features a Home, Login, and Contact form that enables users to access and send feedback to the developer. For demonstration, the submitted queries are saved to theÂ `/submissions`Â directory.Â Below is the screenshot of the application:Â   

![Homepage of he vulnerable application](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/0e26eb0459ab05311e384cff54f6397a.png)  

  

#### Exploiting the Application

UsingÂ Burp SuiteÂ Proxy, intercept a request sent to the website's index. This request will become the baseline we will use to exploit the vulnerable application.

![Baseline request to be used for smuggling](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/540e182a50bb92584e87197341c461f4.png)  

Send the request to Intruder and copy-paste the below payload to the Payload positions box.


```shell-session
POST / HTTP/1.1
Host: httprequestsmuggling.thm
Content-Type: application/x-www-form-urlencoded
Content-Length: 160
Transfer-Encoding: chunked

0

POST /contact.php HTTP/1.1
Host: httprequestsmuggling.thm
Content-Type: application/x-www-form-urlencoded
Content-Length: 500

username=test&query=Â§
```

#### Breakdown of the payload

In CL.TE vulnerability, since theÂ proxyÂ or the front-end prioritises theÂ **Content-Length**Â header, 160 bytes of the body is assumed to be the body of the first POST. The front-end thinks this is a single request and forwards it into the pipeline, where the back-end server now prioritises Transfer-Encoding, ending the first POST request at the firstÂ **0**Â size chunk and assuming the second POST is a different request.

**Payload positions box with the payload**

![Payload positions box with the payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/32964210f678d511e5a75b5e13a5c147.png)

Go to theÂ **Payloads**Â tab and set theÂ **Payload type**Â toÂ **Null payloads**. Subsequently, on theÂ **Payload settings**, input 10000 to generate 10000 null payloads.

![Null payloads settings](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/5e2511d719fc407762ad7551131fae40.png)

Go to theÂ **Resource pool**Â tab and create a new resource pool. You may follow the screenshot below for the settings.

![New resource pool](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/9dfb8dfb97e796d940b2bdc395012485.png)

Click theÂ **Start Attack**Â button in your Intruder tab to start the attack.

![Attack started](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/60e31338ee743a34621d916cea98bff0.png)

After a few minutes, check theÂ `/submissions`Â website directory to see if the request toÂ **contact.php**Â is smuggled containing the request of other users.

**Note:**Â Accessing the vulnerable application while the smuggling is taking effect will capture your request instead of the request from the target user.

![Submissions page containing the saved request](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/92441e957b9c499d4c2d776c76e436dd.png)

Go through the text files to check for the password that was appended to the query parameter.

![.txt file containing the captured request of the target user](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/5604e829b37dfe692febcd2481cf25f4.png)

Use the password to log in to the application.

![Page containing the flag after log in](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/9cd025f997f8a882b3f258a60c198c61.png)

